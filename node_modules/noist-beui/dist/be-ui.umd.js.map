{"version":3,"file":"be-ui.umd.js","sources":["../src/components/button/BeButton.vue","../src/components/button/BeButtons.vue","../src/components/input/BeInput.vue","../src/components/input/BeInputNumber.vue","../src/components/checkbox/BeCheckBox.vue","../src/components/checkbox/BeCheckBoxGroup.vue","../src/components/checkbox/BeRadio.vue","../src/components/list/BeList.vue","../src/components/message/BeMessage.vue","../src/components/pagination/BePagination.vue","../src/components/panel/BePanel.vue","../src/components/radio/BeRadios.vue","../src/components/rate/BeRate.vue","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs","../src/components/selectbox/BeSelectBox.vue","../src/components/switch/BeSwitch.vue","../src/components/table/BeTable.vue","../src/components/tree/BeTreeNode.vue","../src/components/calendar/calendar.js","../src/components/calendar/BeCalendar.vue","../src/components/calendar/BeDatePicker.vue","../src/components/segment/BeSegment.vue","../src/components/tag/BeBadge.vue","../src/components/tabs/BeTabs.vue","../src/components/slider/BeSlider.vue","../src/index.js"],"sourcesContent":["<script setup>\ndefineProps({\n  contentText: {\n    type: String,\n    default: '',\n  },\n  brand: {\n    type: String,\n  },\n  status: {\n    type: String,\n  },\n  color: {\n    type: String,\n  },\n  text: {\n    type: Boolean,\n  },\n  border: {\n    type: Boolean,\n  },\n  disabled: {\n    type: Boolean,\n  },\n  fluid: {\n    type: Boolean,\n  },\n  round: {\n    type: Boolean,\n  },\n  compact: {\n    type: Boolean,\n  },\n  outline: {\n    type: Boolean,\n  },\n  icon: {\n    type: Boolean,\n  },\n  withIcon: {\n    type: String,\n    default: null,\n  },\n  iconPos: {\n    type: String,\n  },\n  badge: {\n    type: String,\n  },\n  badgeOption: {\n    type: String,\n  },\n  link: {\n    type: String,\n    default: null,\n  },\n  linkTarget: {\n    type: String,\n    default: null,\n  },\n})\nconst emit = defineEmits(['onClick'])\nconst onClick = (e) => {\n  emit('onClick', e)\n}\n</script>\n\n<template>\n  <button\n    class=\"be-button\"\n    :class=\"[\n      brand,\n      status,\n      color,\n      { text },\n      { link },\n      { border },\n      { disabled },\n      { fluid },\n      { round },\n      { compact },\n      { outline },\n      { icon },\n      { badge: badge },\n    ]\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <template v-if=\"withIcon && (iconPos === 'left' || iconPos === 'both')\">\n        <i class=\"icon\" :class=\"[iconPos, withIcon]\"></i>\n      </template>\n      <template v-if=\"icon\">\n        <i class=\"icon\" :class=\"icon\"></i>\n      </template>\n      {{ contentText }}\n      <template\n        v-if=\"withIcon && (iconPos === 'right' || iconPos === 'both')\"\n      ></template>\n      <template v-if=\"badge\">\n        <div class=\"in-badge\" :class=\"badgeOption\">{{ badge }}</div>\n      </template>\n    </slot>\n    <a v-if=\"link\" :href=\"link\" :target=\"linkTarget || '_self'\" />\n  </button>\n</template>\n","<script setup>\nimport BeButton from './BeButton.vue'\n\ndefineProps({\n  buttons: {\n    type: Array,\n    required: true,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst selectedIndex = defineModel()\n\nconst handleSelect = (idx) => {\n  selectedIndex.value = idx\n}\n</script>\n\n<template>\n  <div class=\"be-buttons\">\n    <slot>\n      <template v-for=\"(btn, i) in buttons\" :key=\"`btn-${i}`\">\n        <BeButton\n          v-bind=\"btn.option\"\n          @click=\"() => handleSelect(i)\"\n          :class=\"{ selected: selectedIndex === i }\"\n        ></BeButton>\n      </template>\n    </slot>\n  </div>\n</template>\n","<script setup>\nimport { ref, computed } from 'vue'\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'input',\n    validator(value) {\n      return ['input', 'textarea'].includes(value)\n    },\n  },\n  inputType: {\n    type: String,\n    default: 'text',\n  },\n  align: {\n    type: String,\n    default: 'left',\n    validator(value) {\n      return ['left', 'center', 'right'].includes(value)\n    },\n  },\n  status: {\n    type: String,\n    default: null,\n    validator(value) {\n      return ['success', 'error', 'attention', 'info', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  placeholder: {\n    type: String,\n    default: '입력하세요',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  underline: {\n    type: Boolean,\n    default: false,\n  },\n  transparent: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  iconLeft: {\n    type: String,\n    default: null,\n  },\n  iconRight: {\n    type: String,\n    default: null,\n  },\n  clear: {\n    type: Boolean,\n    default: false,\n  },\n  badge: {\n    type: String,\n    default: null,\n  },\n  badgeOption: {\n    type: String,\n    default: null,\n  },\n  edit: {\n    type: Boolean,\n    default: false,\n  },\n  editMode: {\n    type: Boolean,\n    default: false,\n  },\n  unit: {\n    type: String,\n    default: null,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst inputValue = defineModel()\nconst emit = defineEmits(['focus'])\n\nconst isFocus = ref(false)\n\nconst input = ref(null)\nconst iconPosition = computed(() => {\n  if (props.iconLeft && (props.iconRight || props.clear)) return 'both'\n  return props.iconLeft\n    ? 'left'\n    : props.iconRight || props.clear\n      ? 'right'\n      : null\n})\n\nconst checkFocus = () => {\n  if (!isFocus.value) {\n    isFocus.value = true\n    console.log('fucus', isFocus.value)\n    emit('focus', isFocus.value)\n  }\n}\nconst onBlur = () => {\n  isFocus.value = false\n  emit('focus', isFocus.value)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-input\"\n    :class=\"[\n      status,\n      { readonly },\n      { underline },\n      { round },\n      { transparent },\n      { compact },\n      { fluid },\n      { edit: edit },\n      { editable: editMode },\n      { icon: iconLeft || iconRight || clear },\n      iconPosition,\n      { badge: badge },\n      { unit },\n      { disabled },\n    ]\"\n    :data-unit=\"unit\"\n  >\n    <slot>\n      <i v-if=\"iconLeft\" :class=\"`icon xi-${iconLeft}`\" />\n      <template v-if=\"type === 'input'\">\n        <input\n          :type=\"inputType\"\n          v-model=\"inputValue\"\n          :placeholder=\"placeholder\"\n          :class=\"[`aline-${align}`]\"\n          ref=\"input\"\n          :disabled=\"disabled\"\n          :readonly=\"readonly\"\n          @click=\"checkFocus()\"\n          @blur=\"onBlur()\"\n        />\n      </template>\n      <template v-else>\n        <textarea\n          v-model=\"inputValue\"\n          rows=\"3\"\n          :placeholder=\"placeholder\"\n        ></textarea>\n      </template>\n\n      <i\n        v-if=\"clear\"\n        class=\"icon clear-btn xi-close\"\n        :class=\"{ disabled: inputValue === '' }\"\n        @click=\"inputValue = ''\"\n      />\n      <i v-else-if=\"iconRight && !clear\" :class=\"`icon xi-${iconRight}`\" />\n      <span v-else-if=\"badge\" class=\"be-badge\" :class=\"badgeOption\">{{\n        badge\n      }}</span>\n    </slot>\n  </div>\n</template>\n","<script setup>\nimport { ref, onMounted } from 'vue'\nconst props = defineProps({\n  status: {\n    type: String,\n    default: null,\n    validator(value) {\n      return ['success', 'error', 'attention', 'info', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  placeholder: {\n    type: String,\n    default: '',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  iconLeft: {\n    type: String,\n    default: null,\n  },\n  iconRight: {\n    type: String,\n    default: null,\n  },\n  step: {\n    type: Number,\n    default: 1,\n  },\n  controller: {\n    type: String,\n    default: 'between',\n  },\n  min: {\n    type: Number,\n  },\n  max: {\n    type: Number,\n  },\n  incIcon: {\n    type: String,\n    default: 'xi-plus',\n  },\n  decIcon: {\n    type: String,\n    default: 'xi-minus',\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst inputValue = defineModel()\nconst emit = defineEmits(['focus'])\n\nconst isFocus = ref(false)\n\nconst input = ref(null)\n\nonMounted(() => {\n  if (inputValue.value < props.min) inputValue.value = props.min\n  if (inputValue.value > props.max) inputValue.value = props.max\n})\nconst checkFocus = () => {\n  if (!isFocus.value) {\n    isFocus.value = true\n    console.log('fucus', isFocus.value)\n    emit('focus', isFocus.value)\n  }\n}\nconst onBlur = () => {\n  isFocus.value = false\n  emit('focus', isFocus.value)\n}\nconst increase = () => {\n  if (inputValue.value + props.step > props.max) return\n  inputValue.value += props.step\n}\nconst decrease = () => {\n  if (inputValue.value - props.step < props.min) return\n  inputValue.value -= props.step\n}\nconst keyControl = (event) => {\n  if (props.disabled) return\n  if (event.keyCode === 38) increase()\n  if (event.keyCode === 40) decrease()\n}\n</script>\n\n<template>\n  <div\n    class=\"be-input button number\"\n    :class=\"[status, { readonly, compact, fluid, disabled, round }, controller]\"\n    tabindex=\"-1\"\n    @keydown.prevent=\"keyControl\"\n  >\n    <slot>\n      <input\n        type=\"number\"\n        v-model=\"inputValue\"\n        ref=\"input\"\n        @click=\"checkFocus()\"\n        @blur=\"onBlur()\"\n      />\n    </slot>\n    <button class=\"be-button icon dec\" :class=\"{ disabled }\" @click=\"decrease\">\n      <i class=\"icon\" :class=\"decIcon\"></i>\n    </button>\n    <button class=\"be-button icon inc\" :class=\"{ disabled }\" @click=\"increase\">\n      <i class=\"icon\" :class=\"incIcon\"></i>\n    </button>\n  </div>\n</template>\n","<script setup>\ndefineProps({\n  type: {\n    type: String,\n    default: 'checkbox',\n    varidator: (value) => {\n      return ['checkbox', 'radio'].includes(value)\n    },\n  },\n  name: {\n    type: String,\n  },\n  labelText: {\n    type: String,\n    default: null,\n  },\n  indeter: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst checkedValue = defineModel()\n</script>\n\n<template>\n  <div\n    class=\"be-checkbox\"\n    :class=\"[type, { checked: checkedValue }, { indeter }]\"\n    @click=\"checkedValue = !checkedValue\"\n  >\n    <input type=\"checkbox\" :name=\"name\" v-model=\"checkedValue\" />\n    <label>\n      {{ labelText }}\n    </label>\n  </div>\n</template>\n","<script setup>\nimport { ref, onMounted } from 'vue'\nconst props = defineProps({\n  checkList: {\n    type: Array,\n    required: true,\n  },\n})\nconst uniqueId = Math.random().toString(36)\n\nconst emit = defineEmits(['result'])\nconst selectedValue = defineModel('result')\n\nconst checkboxList = ref(new Array(props.checkList.length).fill(false))\n\nonMounted(() => {\n  selectedValue.value.forEach((val) => {\n    const idx = props.checkList.findIndex((c) => c === val)\n    checkboxList.value[idx] = true\n  })\n})\nconst selectCheck = () => {\n  selectedValue.value = props.checkList.filter((c, i) => checkboxList.value[i])\n  emit('result', selectedValue.value)\n  // emit('select-value', checkboxList.value.filter(cb => cb.value))\n}\n</script>\n\n<template>\n  <div class=\"be-checkout-group\">\n    <div\n      v-for=\"(item, i) in checkList\"\n      :key=\"item\"\n      class=\"be-checkbox\"\n      :class=\"{ checked: checkboxList[i] }\"\n    >\n      <input\n        type=\"checkbox\"\n        :id=\"`${item}-${uniqueId}`\"\n        v-model=\"checkboxList[i]\"\n        @change=\"selectCheck\"\n      />\n      <label :for=\"`${item}-${uniqueId}`\">{{ item }}</label>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-checkout-group {\n  display: flex;\n}\n</style>\n","<script setup>\ndefineProps({\n  optionList: {\n    type: Array,\n    required: true,\n  },\n  selected: {\n    type: String,\n    default: '',\n  },\n})\nconst uniqueId = Math.random().toString(36)\n\nconst emit = defineEmits(['result'])\nconst selectedRadio = defineModel('result')\n\nconst selectCheck = () => {\n  emit('result', selectedRadio.value)\n}\n</script>\n\n<template>\n  <div class=\"be-radio\">\n    <div\n      v-for=\"item in optionList\"\n      :key=\"item\"\n      class=\"be-checkbox radio\"\n      :class=\"{ checked: item === selectedRadio }\"\n    >\n      <input\n        type=\"radio\"\n        :id=\"`${item}-${uniqueId}`\"\n        v-model=\"selectedRadio\"\n        :value=\"item\"\n        @change=\"selectCheck\"\n      />\n      <label :for=\"`${item}-${uniqueId}`\">{{ item }}</label>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-radio {\n  display: flex;\n}\n</style>\n","<script setup>\ndefineProps({\n  options: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  selection: {\n    type: Boolean,\n    default: false,\n  },\n  selectedType: {\n    type: String,\n    default: 'bg',\n  },\n  icon: {\n    type: Boolean,\n    default: false,\n  },\n  image: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst selectItem = defineModel()\n</script>\n\n<template>\n  <div class=\"be-list\" :class=\"[{ selection }, { border }, selectedType]\">\n    <div\n      class=\"item\"\n      v-for=\"opt in options\"\n      :key=\"opt.option\"\n      :class=\"{ selected: selectItem && selectItem.option === opt.option }\"\n      @click=\"selectItem = opt\"\n    >\n      <template v-if=\"image\">\n        <div class=\"item-img\">\n          <img :src=\"opt.image\" />\n        </div>\n      </template>\n      <template v-else-if=\"icon\">\n        <i class=\"list-icon icon\" :class=\"opt.icon\" />\n      </template>\n      <div class=\"item-title\">\n        {{ opt.option }}\n        <div class=\"sub-title\" v-if=\"opt.sub\">\n          {{ opt.sub }}\n        </div>\n      </div>\n      <template v-if=\"button\">\n        <div class=\"btn-set\">\n          <div class=\"be-button round icon\">\n            <i :Class=\"opt.icon\"></i>\n          </div>\n        </div>\n      </template>\n    </div>\n  </div>\n</template>\n","<script setup>\nimport { computed } from 'vue'\n\nconst statusIcon = {\n  success: 'xi-check-circle',\n  info: 'xi-info',\n  error: 'xi-emoticon-devil',\n  attention: 'xi-warning',\n  importance: 'xi-star',\n}\n\nconst props = defineProps({\n  title: {\n    type: String,\n  },\n  contents: {\n    type: String,\n  },\n  icon: {\n    type: String,\n  },\n  status: {\n    type: String,\n    default: null,\n    varidator: (value) => {\n      return ['success', 'error', 'info', 'attention', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  selected: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst iconName = computed(() => {\n  if (props.status) {\n    return statusIcon[props.status]\n  } else {\n    return props.icon\n  }\n})\n</script>\n\n<template>\n  <div\n    class=\"be-message\"\n    :class=\"[{ icon: icon }, status, { selected, disabled }]\"\n  >\n    <template v-if=\"icon\">\n      <i class=\"icon\" :class=\"iconName\" />\n    </template>\n    <slot>\n      <div class=\"title\">{{ title }}</div>\n      <div class=\"contents\">{{ contents }}</div>\n    </slot>\n  </div>\n</template>\n","<script setup>\nimport { ref, computed, watch, onMounted, nextTick } from 'vue'\n\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'number',\n    varidator: (value) => {\n      return ['number', 'page'].includes(value)\n    },\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'left',\n  },\n  limits: {\n    type: Number,\n    default: 5,\n  },\n  currentPage: {\n    type: Number,\n    default: 1,\n  },\n  pageLength: {\n    type: Number,\n    default: 1,\n  },\n  itemClass: {\n    type: String,\n  },\n  ellipsis: {\n    type: Boolean,\n    default: false,\n  },\n  color: {\n    type: String,\n  },\n  firstText: {\n    type: String,\n    default: 'F',\n  },\n  lastText: {\n    type: String,\n    default: 'L',\n  },\n  activeType: {\n    type: String,\n    default: 'button', // text\n  },\n})\nconst pageEl = ref(null)\nconst current = defineModel()\nconst emit = defineEmits(['change'])\nconst last = ref(1)\n\nconst pageList = computed(() => {\n  if (offLimits.value) {\n    return new Array(props.pageLength).fill(1).map((n, i) => n + i)\n  } else if (props.ellipsis) {\n    let start = 2\n    let half = Math.floor(props.limits / 2)\n    if (isPrevPoint.value) {\n      start = current.value - half\n    }\n    if (!isNextPoint.value && isPrevPoint.value) {\n      start = last.value - props.limits\n    }\n    return new Array(props.limits).fill(0).map((n, i) => start + i)\n  } else {\n    let start = Math.min(findStart.value, props.pageLength - props.limits + 1)\n    return new Array(props.limits).fill(start).map((n, i) => n + i)\n  }\n})\nconst findStart = computed(() => {\n  return Math.max(current.value - Math.ceil(props.limits * 0.5) + 1, 1)\n})\n// const isSingle = computed(() => {\n//   return props.pageLength === 1\n// })\nconst isPrevPoint = computed(() => {\n  return (\n    current.value > Math.floor(props.limits / 2) + 2 &&\n    props.limits < last.value\n  )\n})\nconst isNextPoint = computed(() => {\n  return current.value <= last.value - props.limits && props.limits < last.value\n})\nconst isDisabledNext = computed(() => {\n  return current.value + 1 > last.value\n})\nconst isDisabledPrev = computed(() => {\n  return current.value - 1 <= 0\n})\nconst offLimits = computed(() => {\n  return props.pageLength <= props.limits || !props.limits\n})\n\nwatch(props, () => {\n  last.value = props.pageLength\n})\n\nonMounted(async () => {\n  await nextTick()\n  pageEl.value.focus()\n  // current.value = props.currentPage\n  last.value = props.pageLength\n})\n\nconst setCurrent = (num) => {\n  if (num > last.value || num <= 0) return\n  current.value = num\n  emit('change', num)\n}\nconst setPrev = () => {\n  if (isDisabledPrev.value) return\n  setCurrent(current.value - 1)\n}\nconst setNext = () => {\n  if (isDisabledNext.value) return\n  setCurrent(current.value + 1)\n}\nconst setPrevBlock = () => {\n  let prevNum =\n    current.value - props.limits <= 0\n      ? current.value - 1\n      : current.value - props.limits\n  setCurrent(prevNum)\n}\nconst setNextBlock = () => {\n  let prevNum =\n    current.value + props.limits > last.value\n      ? current.value + 1\n      : current.value + props.limits\n  setCurrent(prevNum)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-pagination\"\n    :class=\"[type, activeType, { round }, { compact }, `align-${align}`, color]\"\n    ref=\"pageEl\"\n  >\n    <div\n      v-if=\"!ellipsis && !offLimits\"\n      class=\"pagination-nav first\"\n      :class=\"[itemClass, { disabled: isDisabledPrev }]\"\n      @click=\"setCurrent(1)\"\n    >\n      <template v-if=\"firstText.indexOf('xi-') > -1\">\n        <i :class=\"firstText\" />\n      </template>\n      <template v-else>{{ firstText }}</template>\n    </div>\n    <div\n      class=\"pagination-nav prev\"\n      :class=\"[itemClass, { disabled: isDisabledPrev }]\"\n      @click=\"setPrev\"\n    >\n      <i class=\"xi-angle-left\"></i>\n    </div>\n    <template v-if=\"ellipsis\">\n      <div\n        class=\"pagination-num\"\n        :class=\"[itemClass, { active: 1 === current }]\"\n        @click=\"setCurrent(1)\"\n      >\n        1\n      </div>\n      <div\n        v-if=\"isPrevPoint\"\n        class=\"pagination-num\"\n        :class=\"[itemClass]\"\n        @click=\"setPrevBlock\"\n      >\n        <i class=\"xi-ellipsis-h\"></i>\n      </div>\n    </template>\n    <div class=\"pagination-page-wrapper\">\n      <template v-if=\"type === 'number'\">\n        <div\n          class=\"pagination-num\"\n          v-for=\"page in pageList\"\n          :key=\"page\"\n          :class=\"[itemClass, { active: page === current }]\"\n          @click=\"setCurrent(page)\"\n        >\n          {{ page }}\n        </div>\n      </template>\n      <template v-else>\n        <div class=\"pagination-info\">\n          <div class=\"pagination-nav current\">{{ current }}</div>\n          <span class=\"slash\">/</span>\n          <div class=\"pagination-nav\" last>{{ last }}</div>\n        </div>\n      </template>\n    </div>\n    <template v-if=\"ellipsis && props.limits < props.pageLength\">\n      <div\n        v-if=\"isNextPoint\"\n        class=\"pagination-nav\"\n        :class=\"[itemClass]\"\n        @click=\"setNextBlock\"\n      >\n        <i class=\"xi-ellipsis-h\"></i>\n      </div>\n      <div\n        class=\"pagination-num\"\n        :class=\"[itemClass, { active: last === current }]\"\n        @click=\"setCurrent(last)\"\n      >\n        {{ last }}\n      </div>\n    </template>\n    <div\n      class=\"pagination-nav next\"\n      :class=\"[itemClass, { disabled: isDisabledNext }]\"\n      @click=\"setNext\"\n    >\n      <i class=\"xi-angle-right\"></i>\n    </div>\n    <div\n      v-if=\"!ellipsis && !offLimits\"\n      class=\"pagination-nav last\"\n      :class=\"[itemClass, { disabled: isDisabledNext }]\"\n      @click=\"setCurrent(last)\"\n    >\n      <template v-if=\"lastText.indexOf('xi-') > -1\">\n        <i :class=\"lastText\" />\n      </template>\n      <template v-else>{{ lastText }}</template>\n    </div>\n  </div>\n</template>\n","<script setup>\nimport { ref, computed } from 'vue'\nconst props = defineProps({\n  title: {\n    type: String,\n  },\n  contents: {\n    type: String,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  toggleIcon: {\n    type: String,\n    default: null,\n  },\n  iconPos: {\n    type: String,\n    default: 'left',\n  },\n  open: {\n    type: Boolean,\n    default: false,\n  },\n  collapse: {\n    type: Boolean,\n    default: false,\n  },\n  maxHeight: {\n    type: Number,\n    default: 200,\n  },\n})\n\nconst emit = defineEmits(['show'])\nconst isOpen = ref(props.open)\nconst iconClass = computed(() => {\n  if (!props.toggleIcon && props.collapse) return ''\n  return `icon ${props.iconPos}`\n})\n\nconst setHeight = computed(() => {\n  if (!props.collapse) return {}\n  return {\n    '--max-height': `${props.maxHeight}px`,\n  }\n})\n\nconst showPanel = () => {\n  if (!props.collapse) return\n  isOpen.value = !isOpen.value\n  emit('show', isOpen.value)\n}\n</script>\n<template>\n  <div\n    class=\"be-panel\"\n    :class=\"[{ border, collapse }, iconClass, { open: isOpen }]\"\n  >\n    <div class=\"panel-header\" @click=\"showPanel\">\n      <div class=\"title\">{{ title }}</div>\n      <span v-if=\"collapse && toggleIcon\">\n        <i class=\"icon\" :class=\"`${toggleIcon}`\"></i>\n      </span>\n    </div>\n    <div class=\"panel-content\" :style=\"setHeight\">\n      <div class=\"content-wrapper\">\n        <slot name=\"contents\">\n          {{ contents }}\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n","<script setup>\nimport { computed } from 'vue'\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'checkbox',\n    varidator: (value) => {\n      return ['checkbox', 'radio'].includes(value)\n    },\n  },\n  id: {\n    type: String,\n  },\n  name: {\n    type: String,\n  },\n  labelText: {\n    type: String,\n    default: '',\n  },\n})\n\nconst checkedValue = defineModel()\n\nconst setValue = computed(() => {\n  if (props.type === 'radio') {\n    return checkedValue.value === props.id\n  } else {\n    return checkedValue.value\n  }\n})\n</script>\n\n<template>\n  <div class=\"be-checkbox\" :class=\"[type, { checked: setValue }]\">\n    <input\n      :type=\"type\"\n      :name=\"name\"\n      :id=\"id\"\n      v-model=\"checkedValue\"\n      :value=\"id\"\n    />\n    <label :for=\"id\">\n      <slot>{{ labelText }}</slot>\n    </label>\n  </div>\n</template>\n","<script setup>\nimport { ref, onMounted, computed, watch } from 'vue'\n\nconst props = defineProps({\n  rateLength: {\n    type: Number,\n    default: 5,\n  },\n  useHalf: {\n    type: Boolean,\n    default: false,\n  },\n  icon: {\n    type: String,\n    default: 'xi-star',\n  },\n  resultValue: {\n    type: Number,\n    default: 0,\n  },\n  size: {\n    type: String,\n    default: null,\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  color: {\n    type: String,\n    default: null,\n  },\n  border: {\n    type: Boolean,\n    default: true,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  clearable: {\n    type: Boolean,\n    default: true,\n  },\n})\n\nconst emit = defineEmits(['select'])\nconst rate = ref(0)\nconst result = ref(0)\nconst isHalf = ref(false)\nconst isFloat = ref(0)\n\nconst setFloat = computed(() => {\n  const percent = ((rate.value * 10) % 10) * 10\n  if (percent === 0) return {}\n  return {\n    width: `${percent}%`,\n    overflow: 'hidden',\n  }\n})\n\nwatch(\n  () => props.resultValue,\n  () => {\n    rate.value = props.resultValue\n    result.value = props.resultValue\n  },\n  { immediate: true },\n)\nonMounted(() => {\n  isFloat.value = ((rate.value * 10) % 10) * 10\n})\nconst onHover = (num) => {\n  if (props.useHalf) {\n    const targetPos = event.target.getBoundingClientRect()\n    isHalf.value = targetPos.left + targetPos.width / 2 - event.pageX > 0\n  }\n  rate.value = num\n}\n\nconst onMove = (num) => {\n  if (!props.useHalf) return\n  onHover(num)\n}\nconst onLeave = () => {\n  rate.value = result.value || 0\n}\n\nconst setRate = (num) => {\n  if (props.clearable) {\n    result.value = Math.ceil(result.value) === num ? 0 : result.value\n  }\n  result.value = result.value === num ? 0 : num\n  if (props.useHalf) {\n    result.value = isHalf.value ? num - 0.5 : num\n  }\n  emit('select', result.value)\n}\n</script>\n\n<template>\n  <div class=\"be-rate\" :class=\"[size, color, { readonly, disabled, border }]\">\n    <span\n      v-for=\"item in rateLength\"\n      :key=\"item\"\n      class=\"rate-item\"\n      :class=\"[\n        { check: Math.ceil(rate) >= item },\n        { half: Math.ceil(rate) === item && isHalf },\n      ]\"\n      @mouseenter=\"onHover(item)\"\n      @mouseleave=\"onLeave\"\n      @mousemove=\"onMove(item)\"\n      @click=\"setRate(item)\"\n    >\n      <i class=\"icon\" :class=\"`${icon}-o`\"></i>\n      <i\n        class=\"icon\"\n        :class=\"icon\"\n        :style=\"Math.ceil(rate) === item ? setFloat : null\"\n      ></i>\n    </span>\n  </div>\n</template>\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\nfunction toValue(source) {\n  return typeof source === 'function' ? source() : unref(source);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(toValue(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _toValue;\n    return (_toValue = toValue(options.open)) != null ? _toValue : true;\n  });\n  const middlewareOption = computed(() => toValue(options.middleware));\n  const placementOption = computed(() => {\n    var _toValue2;\n    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _toValue3;\n    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _toValue4;\n    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    const open = openOption.value;\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      /**\n       * The floating element's position may be recomputed while it's closed\n       * but still mounted (such as when transitioning out). To ensure\n       * `isPositioned` will be `false` initially on the next open, avoid\n       * setting it to `true` when `open === false` (must be specified).\n       */\n      isPositioned.value = open !== false;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption, openOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","<script setup>\nimport { ref, reactive, computed, watch, onMounted, onUnmounted } from 'vue'\nimport { useFloating, autoUpdate, offset, flip, shift } from '@floating-ui/vue'\n\nconst props = defineProps({\n  target: {\n    type: String,\n  },\n  options: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  selectedValue: {\n    type: [Array, Object, String],\n    default: () => {\n      return null\n    },\n  },\n  boxType: {\n    type: String,\n    default: 'dropdown', // dropdown, float\n  },\n  placeholder: {\n    type: String,\n    default: '선택하세요',\n  },\n  isSearch: {\n    type: Boolean,\n    default: false,\n  },\n  useIcon: {\n    type: Boolean,\n    default: false,\n  },\n  multiple: {\n    type: Boolean,\n    default: false,\n  },\n  maxOptHeight: {\n    type: Number,\n    default: 260,\n  },\n  selectedType: {\n    type: String,\n    default: 'bg',\n  },\n  optionKey: {\n    type: String,\n    default: 'option',\n  },\n  resultKey: {\n    type: String,\n    default: 'val',\n  },\n  isAll: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emit = defineEmits(['select'])\n// const selectedValue = defineModel()\n\nconst elRef = ref(null)\nconst menu = ref(null)\nconst isShow = ref(false)\n\nconst reference = ref(null)\nconst floating = ref(null)\n\nconst selectedItem = ref(null)\nconst selectedList = ref([])\nconst optionList = reactive(props.options)\nconst searchText = ref(null)\n\nconst offsetValue = props.boxType === 'dropdown' ? 10 : 0\n\nconst { x, y, strategy, isPositioned } = useFloating(reference, floating, {\n  middleware: [offset(offsetValue), flip(), shift()],\n  whileElementsMounted: autoUpdate,\n})\n\nconst customFloatingStyle = computed(() => {\n  const floatOffset =\n    props.boxType === 'dropdown' ? 0 : (selectedIndex.value + 1) * -37\n  return {\n    position: strategy.value,\n    inset: `0 auto auto 0`,\n    transform: `translate(${x.value}px, ${y.value + floatOffset}px)`,\n  }\n})\n\nwatch(isPositioned, () => {\n  floating.value.focus()\n})\n\nconst selectedText = computed(() => {\n  if (props.multiple) {\n    return selectedList.value.length > 0\n      ? `${selectedList.value.length} 개 선택`\n      : null\n  } else {\n    const selectIndex = props.options.findIndex(\n      (t) => t[props.resultKey] === selectedItem.value,\n    )\n    return props.options[selectIndex]\n      ? props.options[selectIndex][props.optionKey]\n      : null\n  }\n})\n\nconst selectedIndex = computed(() => {\n  return selectedItem.value\n    ? searchedOptions.value.findIndex(\n        (f) => f[props.resultKey] === selectedItem.value,\n      )\n    : 0\n})\n\nconst searchedOptions = computed(() => {\n  if (props.isSearch && searchText.value && !props.multiple) {\n    return optionList.filter(\n      (item) =>\n        item[props.optionKey]\n          .toLowerCase()\n          .indexOf(searchText.value.toLowerCase()) > -1,\n    )\n  } else {\n    return optionList\n  }\n})\nconst optionsHeight = computed(() => {\n  if (!props.maxOptHeight) return\n  return { maxHeight: props.maxOptHeight + 'px' }\n})\n\nwatch(props, () => {\n  initValue()\n})\n\nonMounted(() => {\n  initValue()\n  window.addEventListener('click', () => showMenu(false))\n})\nonUnmounted(() => {\n  window.removeEventListener('click', () => showMenu(false))\n})\n\nconst initValue = () => {\n  if (props.multiple) {\n    selectedList.value = props.selectedValue ? props.selectedValue : []\n    selectedItem.value = props.selectedValue\n      ? `${props.selectedValue.length} 개 선택`\n      : null\n  } else {\n    selectedItem.value = props.selectedValue\n  }\n}\n\nconst menuPos = ref('down')\n\nconst setMenuStyle = computed(() => {\n  if (!isShow.value) return\n  const posEl = elRef.value.getBoundingClientRect()\n  if (menuPos.value === 'up') {\n    return {\n      width: posEl.width + 'px',\n      // top: posEl.top - (Number(props.maxOptHeight) + 10) + 'px',\n      // left: posEl.left + 'px',\n    }\n  } else {\n    return {\n      width: posEl.width + 'px',\n      // top:\n      //   props.boxType === 'dropdown'\n      //     ? posEl.bottom + 'px'\n      //     : posEl.top - selectedIndex.value * 37 + 'px',\n      // left: posEl.left + 'px',\n    }\n  }\n})\n\nconst toggleOpen = () => {\n  if (props.multiple && isShow.value) return\n  isShow.value = !isShow.value\n}\n\nconst selectItem = (value) => {\n  if (props.multiple) {\n    setMultipleList(value)\n  } else {\n    searchText.value = null\n    selectedItem.value = value[props.resultKey]\n    emit('select', selectedItem.value, props.target)\n    isShow.value = false\n  }\n}\n\nconst showMenu = (value = true) => {\n  if (\n    elRef.value?.contains(event.target) ||\n    floating.value?.contains(event.target)\n  )\n    return\n  if (isShow.value) value = false\n  isShow.value = value\n}\n\nconst setMultipleList = (item) => {\n  if (selectedList.value.includes(item[props.resultKey])) {\n    const same = selectedList.value.findIndex(\n      (c) => item[props.resultKey] === c,\n    )\n    selectedList.value.splice(same, 1)\n  } else {\n    selectedList.value.push(item[props.resultKey])\n  }\n  emit('select', selectedList.value, props.target)\n}\n\nconst selectAll = () => {\n  selectedList.value = [...searchedOptions.value].map(\n    (se) => se[props.resultKey],\n  )\n  emit('select', selectedList.value, props.target)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-select-box\"\n    :class=\"[boxType, { multiple, fluid, disabled, round }, { show: isShow }]\"\n    @click=\"toggleOpen\"\n    ref=\"elRef\"\n  >\n    <div class=\"selected-item\" ref=\"reference\">\n      <template v-if=\"!isSearch\">\n        <div class=\"default-text\" :class=\"{ has: selectedItem }\">\n          {{ selectedText || placeholder }}\n        </div>\n      </template>\n      <template v-else>\n        <div\n          class=\"be-input icon right\"\n          :class=\"{ fluid, disabled, round, has: selectedItem }\"\n        >\n          <input\n            type=\"text\"\n            :placeholder=\"selectedText || placeholder\"\n            v-model=\"searchText\"\n            :readonly=\"!isSearch || !isShow\"\n          />\n        </div>\n      </template>\n      <i\n        v-if=\"isShow && multiple\"\n        class=\"icon xi-close\"\n        :style=\"{ pointerEvents: 'auto' }\"\n        @click.stop=\"isShow = false\"\n      ></i>\n      <i v-else class=\"icon xi-angle-down\"></i>\n    </div>\n    <Teleport to=\"body\">\n      <div\n        v-if=\"isShow\"\n        class=\"be-popper-container\"\n        ref=\"floating\"\n        :style=\"customFloatingStyle\"\n      >\n        <Transition name=\"extend-fade\">\n          <div\n            v-if=\"isShow\"\n            class=\"select-menu be-popper\"\n            :style=\"[optionsHeight, setMenuStyle]\"\n          >\n            <div class=\"be-list selection\" :class=\"selectedType\" ref=\"menu\">\n              <div\n                v-if=\"isSearch && searchedOptions.length === 0\"\n                class=\"no-searched\"\n              >\n                검색 결과가 없습니다.\n              </div>\n              <template v-else>\n                <div\n                  v-if=\"isAll && multiple\"\n                  class=\"item option-item\"\n                  @click=\"selectAll\"\n                >\n                  전체\n                </div>\n                <div\n                  class=\"item option-item\"\n                  v-for=\"(opt, idx) in searchedOptions\"\n                  :key=\"`option-${idx}`\"\n                  :class=\"[\n                    { selected: opt[resultKey] === selectedItem },\n                    { include: selectedList.includes(opt[resultKey]) },\n                  ]\"\n                  @click=\"selectItem(opt, idx)\"\n                >\n                  <template v-if=\"useIcon\">\n                    <i class=\"list-icon icon\" :class=\"opt.icon\"></i>\n                  </template>\n                  <div class=\"item-title\">\n                    {{ opt[props.optionKey] }}\n                  </div>\n                </div>\n              </template>\n            </div>\n          </div>\n        </Transition>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<style lang=\"scss\">\n.no-searched {\n  padding: 0.5rem;\n}\n.be-select-box {\n  .be-list {\n    .item {\n      padding: 1rem;\n    }\n  }\n  .be-input {\n    &.has input::placeholder {\n      opacity: 1;\n      color: var(--txt);\n    }\n  }\n}\n// .select-menu {\n//   position: absolute;\n//   inset: 0 auto auto 0;\n//   display: block;\n//   transform: translateY(0);\n//   overflow-y: auto;\n//   opacity: 1;\n// }\n.extend-fade-enter-active,\n.extend-fade-leave-active {\n  transition:\n    opacity 0.25s,\n    transform 0.25s;\n}\n.extend-fade-leave-active {\n  transition: transform 0.25s;\n}\n.extend-fade-enter-from,\n.extend-fade-leave-to {\n  opacity: 0;\n  transform: translateY(-10px);\n}\n</style>\n","<script setup>\ndefineProps({\n  type: {\n    type: String,\n    default: 'slide',\n    varidator: (value) => {\n      return ['slide', 'button', 'button-slide'].includes(value)\n    },\n  },\n  inside: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n  },\n  onText: {\n    type: String,\n    default: 'ON',\n  },\n  offText: {\n    type: String,\n    default: 'OFF',\n  },\n  color: {\n    type: String,\n  },\n})\nconst switchValue = defineModel()\nconst emit = defineEmits(['change'])\n\nconst onClick = () => {\n  switchValue.value = !switchValue.value\n  emit('change', switchValue.value)\n}\n</script>\n<template>\n  <div\n    class=\"be-switch\"\n    :class=\"[type, { inside }, { round: round }, color]\"\n    @click=\"onClick\"\n  >\n    <input type=\"checkbox\" v-model=\"switchValue\" />\n    <template v-if=\"type === 'slide'\">\n      <div class=\"switch\"></div>\n    </template>\n    <template v-else>\n      <span class=\"on\" :class=\"{ active: switchValue }\">{{ onText }}</span>\n      <span class=\"off\" :class=\"{ active: !switchValue }\">{{ offText }}</span>\n    </template>\n  </div>\n</template>\n","<script setup>\nimport { ref, computed } from 'vue'\n\nconst props = defineProps({\n  columns: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  values: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  headerAlign: {\n    type: String,\n    default: 'center',\n  },\n  useFoot: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  gridType: {\n    type: String,\n    default: null,\n  },\n  divideNum: {\n    type: [String || Number],\n    default: 3,\n  },\n  selection: {\n    type: Boolean,\n    default: false,\n  },\n  striped: {\n    type: String,\n    default: null,\n  },\n})\nconst emit = defineEmits(['select'])\nconst selectedRow = ref('')\nconst gridClass = computed(() => {\n  if (props.gridType === 'divide') {\n    return `divide-${props.divideNum}`\n  } else {\n    return props.gridType\n  }\n})\n\nconst setSelect = (row) => {\n  if (!props.selection) return\n  selectedRow.value = selectedRow.value === row ? null : row\n  emit('select', props.values[selectedRow.value] || null)\n}\n</script>\n\n<template>\n  <table\n    class=\"be-table\"\n    :class=\"[{ border, selection, striped }, gridClass, striped]\"\n  >\n    <thead>\n      <tr :class=\"`align-${headerAlign}`\">\n        <th\n          v-for=\"col in columns\"\n          :key=\"col.key\"\n          :class=\"`align-${headerAlign}`\"\n        >\n          {{ col.name }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr\n        v-for=\"(row, i) in values\"\n        :key=\"`row-${i}`\"\n        :class=\"{ select: selectedRow === i }\"\n        @click=\"setSelect(i)\"\n      >\n        <td\n          v-for=\"col in columns\"\n          :key=\"`cell-${i}-${col.key}`\"\n          :class=\"[`align-${col.align || 'center'}`, `col-${col.col}`]\"\n        >\n          <div class=\"cell\">\n            {{ row[col.key] }}\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <!-- <tfoot v-if=\"useFoot\">\n      <tr>\n        <slot name=\"footer\">\n          <td :colspan=\"columns.length\">Footer</td>\n        </slot>\n      </tr>\n    </tfoot> -->\n  </table>\n</template>\n","<script setup>\nimport { ref } from 'vue'\nconst props = defineProps({\n  node: {\n    type: Object,\n    default: () => {\n      return {}\n    },\n  },\n  level: {\n    type: Number,\n    default: 0,\n  },\n  useCheck: {\n    type: Boolean,\n    default: false,\n  },\n  useMark: {\n    type: Boolean,\n    default: true,\n  },\n  check: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst showNode = ref(false)\nconst checked = ref(props.check)\nconst toggleNode = (e) => {\n  if (e.target.tagName === 'LABEL') return\n  showNode.value = !showNode.value\n}\n</script>\n<template>\n  <div\n    class=\"be-tree\"\n    :class=\"{ show: showNode }\"\n    :style=\"{ '--level': level }\"\n  >\n    <div class=\"node custom-node\" @click=\"toggleNode\">\n      <div class=\"node-title\">\n        <i\n          v-if=\"useMark\"\n          class=\"icon expend-icon\"\n          :class=\"{ 'xi-caret-down-min': node.children?.length > 0 }\"\n        ></i>\n        <div class=\"node-label\">\n          <template v-if=\"useCheck\">\n            <be-check-box v-model=\"checked\" @update:modelValue=\"updateCheck\" />\n          </template>\n          <div class=\"title\">\n            {{ node.label }}\n          </div>\n          <div v-if=\"node.sub\" class=\"sub-title\">{{ node.sub }}</div>\n        </div>\n      </div>\n    </div>\n    <div v-if=\"showNode && node.children?.length > 0\" class=\"node-children\">\n      <be-tree-node\n        v-for=\"(child, i) in node.children\"\n        :key=\"`level-${level}-${i + 1}`\"\n        :node=\"child\"\n        :level=\"level + 1\"\n        :use-check=\"useCheck\"\n        :use-mark=\"useMark\"\n        :check=\"check\"\n      />\n    </div>\n  </div>\n</template>\n","const lastDayList = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nexport const week_kr = ['일', '월', '화', '수', '목', '금', '토']\nexport const week_kr_l = [\n  '일요일',\n  '월요일',\n  '화요일',\n  '수요일',\n  '목요일',\n  '금요일',\n  '토요일',\n]\nexport const week_en_s = ['S', 'M', 'T', 'W', 'T', 'F', 'S']\nexport const week_en_m = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']\n// const week_en_l = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\nexport const week_en_l = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n]\nexport const MONTH_TEXT_LIST = [\n  'January',\n  'February',\n  'March',\n  'April',\n  'May',\n  'June',\n  'July',\n  'August',\n  'September',\n  'October',\n  'November',\n  'December',\n]\nexport const MONTH_TEXT_LIST_SHORT = [\n  'Jan.',\n  'Feb.',\n  'Mar.',\n  'Apr.',\n  'May',\n  'Jun.',\n  'Jul.',\n  'Aug.',\n  'Sep.',\n  'Oct.',\n  'Nov.',\n  'Dec.',\n]\n\nexport const getDateInfo = (date = new Date()) => {\n  const newDate = typeof date === 'string' ? new Date(date) : date\n  const y = newDate.getFullYear()\n  const m = newDate.getMonth() + 1\n  const d = newDate.getDate()\n  return { year: y, month: m, date: d }\n}\nconst getStartDay = (year, month) => {\n  let startIndex = 0\n\n  let basicDay = 365 * (year - 1) // 현재 월 기준 전년까지 기본 일 수\n  // 윤년 계산\n  let leafDay =\n    Math.floor((year - 1) / 4) -\n    Math.floor((year - 1) / 100) +\n    Math.floor((year - 1) / 400)\n  // 현재 해 오늘까지의 일 수\n  let currentYearDay = 1\n\n  if (month > 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n    lastDayList[1] = 29\n  } else {\n    lastDayList[1] = 28\n  }\n\n  for (let i = 0; i < month - 1; i++) {\n    currentYearDay += lastDayList[i]\n  }\n  startIndex = (basicDay + leafDay + currentYearDay) % 7\n  return startIndex\n}\n\nexport const setCalendar = ({ year, month, date }) => {\n  const now = getDateInfo()\n  let startDay = getStartDay(year, month)\n\n  let dayList = []\n\n  let currLast = lastDayList[month - 1]\n  let prevLast = month === 1 ? 31 : lastDayList[month - 2]\n\n  let currDay = 1\n  let nextDay = 1\n\n  for (let i = 0; i < 6; i++) {\n    for (let j = 0; j < 7; j++) {\n      let cell = {\n        position: {\n          x: 0,\n          y: 0,\n        },\n        disabled: false,\n        type: [],\n        name: '',\n      }\n      cell.position.x = j\n      cell.position.y = i\n      if (i === 0 && j < startDay) {\n        cell.type.push('prev')\n        cell.name = prevLast + (j - startDay) + 1\n      } else if (currDay <= currLast) {\n        if (j === 0) {\n          cell.type.push('sun')\n        }\n        if (j === 6) {\n          cell.type.push('sat')\n        }\n        if (now.year === year && now.month === month && currDay === now.date) {\n          cell.type.push('today')\n        }\n        cell.name = currDay\n        currDay++\n      } else {\n        cell.type.push('next')\n        cell.name = nextDay\n        nextDay++\n      }\n      dayList.push(cell)\n    }\n  }\n  if (nextDay > 7) {\n    dayList = dayList.slice(0, -7)\n  }\n  return dayList\n}\n\n//\n// document.getElementById('calDate').addEventListener('click', () => {\n//     const result = setCalendar(2022, 11);\n//     console.log(result);\n// })\n","<script setup>\nimport {\n  setCalendar,\n  getDateInfo,\n  week_en_m,\n  MONTH_TEXT_LIST,\n} from './calendar'\nimport { ref, watch, computed } from 'vue'\n\nconst week = week_en_m\n\nconst props = defineProps({\n  selectedDate: {\n    type: [String, Date],\n    default: new Date(),\n  },\n  cellSize: {\n    type: String,\n    default: '37px',\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  symmetry: {\n    type: Boolean,\n    default: false,\n  },\n  today: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emits = defineEmits(['select'])\n\nconst currentDate = ref(null)\nconst selectDate = ref(null)\nconst dayList = ref([])\n\nconst cellRows = computed(() => {\n  return dayList.value.length / 7\n})\nwatch(\n  () => props.selectedDate,\n  (value) => {\n    const newValue = typeof value === 'string' ? new Date(value) : value\n    currentDate.value = getDateInfo(newValue)\n    selectDate.value = getDateInfo(newValue)\n    dayList.value = setCalendar(currentDate.value)\n  },\n  { immediate: true },\n)\n\nconst setDayList = () => {\n  if (currentDate.value) {\n    dayList.value = setCalendar(currentDate.value)\n  }\n}\n\nconst prevMonth = () => {\n  currentDate.value.month -= 1\n  if (currentDate.value.month <= 0) {\n    currentDate.value.year -= 1\n    currentDate.value.month = 12\n  }\n  setDayList()\n}\nconst nextMonth = () => {\n  currentDate.value.month += 1\n  if (currentDate.value.month > 12) {\n    currentDate.value.year += 1\n    currentDate.value.month = 1\n  }\n  setDayList()\n}\n\nconst setSelectDate = (date) => {\n  const { year, month } = currentDate.value\n  currentDate.value.date = date\n  selectDate.value = {\n    year,\n    month,\n    date,\n  }\n\n  emits('select', new Date(year, month - 1, date))\n}\nconst checkSelectDate = (date) =>\n  currentDate.value.year === selectDate.value.year &&\n  currentDate.value.month === selectDate.value.month &&\n  currentDate.value.date === date\n\nconst setToday = () => {\n  currentDate.value = getDateInfo()\n  selectDate.value = getDateInfo()\n\n  emits('select', new Date())\n  setDayList()\n}\n</script>\n\n<template>\n  <div\n    class=\"be-calendar\"\n    :class=\"{ border }\"\n    :style=\"{ '--cell-size': cellSize }\"\n  >\n    <div class=\"calendar-header\" :class=\"{ symmetry }\">\n      <slot name=\"current-date\">\n        <div class=\"current-date\">\n          <span class=\"month\">{{\n            MONTH_TEXT_LIST[currentDate.month - 1]\n          }}</span>\n          <span class=\"year\">{{ currentDate.year }}</span>\n        </div>\n      </slot>\n      <slot name=\"controller\">\n        <div class=\"prev-month be-button text icon small\" @click=\"prevMonth\">\n          <i class=\"icon xi-angle-left\" />\n        </div>\n        <div class=\"next-month be-button text icon small\" @click=\"nextMonth\">\n          <i class=\"icon xi-angle-right\" />\n        </div>\n      </slot>\n      <div\n        v-if=\"today\"\n        class=\"be-button small compact round outline deepblue\"\n        @click=\"setToday\"\n      >\n        Today\n      </div>\n    </div>\n    <div class=\"week-wrapper\">\n      <div\n        class=\"cell week-cell\"\n        v-for=\"day in week\"\n        :key=\"day\"\n        :data-name=\"day\"\n      ></div>\n    </div>\n    <div class=\"cell-wrapper\" :style=\"{ '--cell-rows': cellRows }\">\n      <div\n        class=\"cell\"\n        v-for=\"day in dayList\"\n        :key=\"day\"\n        :data-name=\"day.name\"\n        :class=\"[...day.type, { selected: checkSelectDate(day.name) }]\"\n        :style=\"{ '--x': day.position.x, '--y': day.position.y }\"\n        @click=\"setSelectDate(day.name)\"\n      ></div>\n    </div>\n    <slot name=\"footer\">\n      <div class=\"calendar-footer\"></div>\n    </slot>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped></style>\n","<script setup>\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport { useFloating, autoUpdate, offset, flip, shift } from '@floating-ui/vue'\n\nconst props = defineProps({\n  selectedDate: {\n    type: [String, Date],\n    default: new Date(),\n  },\n  cellSize: {\n    type: String,\n    default: '37px',\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  symmetry: {\n    type: Boolean,\n    default: false,\n  },\n  today: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emits = defineEmits(['select'])\n\nconst el = ref(null)\nconst isShow = ref(false)\nconst date = ref(props.selectedDate)\nconst reference = ref(null)\nconst floating = ref(null)\n\nconst { floatingStyles, isPositioned } = useFloating(reference, floating, {\n  placement: 'bottom-start',\n  middleware: [offset(10), flip(), shift()],\n  whileElementsMounted: autoUpdate,\n})\n\nconst setSelectedData = (payload) => {\n  date.value = payload\n  emits('select', date.value)\n}\n\nconst formattedDate = computed(() => {\n  let dateValue = date.value\n  if (typeof dateValue === 'string') dateValue = new Date(dateValue)\n  const year = dateValue.getFullYear()\n  const month = dateValue.getMonth() + 1\n  const day = dateValue.getDate()\n\n  return `${year}.${String(month).padStart(2, '0')}.${String(day).padStart(2, '0')}`\n})\n\nconst menuStyle = ref(null)\nconst MAX_MENU_HEIGHT = 350\n\nconst toggleOpen = () => {\n  isShow.value = !isShow.value\n}\n\nconst showMenu = (value = true) => {\n  if (el.value.contains(event.target) || floating.value.contains(event.target))\n    return\n  if (isShow.value) value = false\n  isShow.value = value\n}\n\nonMounted(() => {\n  document.addEventListener('click', () => showMenu(false))\n})\nonUnmounted(() => {\n  document.removeEventListener('click', () => showMenu(false))\n})\n</script>\n\n<template>\n  <div class=\"be-date-picker\" ref=\"el\">\n    <div class=\"default-date-text\" ref=\"reference\" @click=\"toggleOpen\">\n      <div class=\"be-button icon small round\">\n        <i class=\"icon xi-calendar\"></i>\n      </div>\n      <input type=\"text\" readonly :value=\"formattedDate\" />\n      <i class=\"icon xi-angle-down\" :class=\"{ 'xi-rotate-180': isShow }\"></i>\n    </div>\n    <Teleport to=\"body\">\n      <div class=\"be-popper-container\" ref=\"floating\" :style=\"[floatingStyles]\">\n        <Transition name=\"expend-fade\">\n          <div\n            v-if=\"isShow\"\n            class=\"calender-wrapper be-popper\"\n            :style=\"menuStyle\"\n          >\n            <BeCalendar\n              :selected-date=\"date\"\n              :cell-size=\"cellSize\"\n              :border=\"border\"\n              :symmetry=\"symmetry\"\n              :today=\"today\"\n              @select=\"setSelectedData\"\n            >\n              <div class=\"calendar-footer\">\n                <template slots=\"footer\">\n                  <div class=\"be-button\">Close</div>\n                </template>\n              </div>\n            </BeCalendar>\n          </div>\n        </Transition>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-date-picker {\n  position: relative;\n  .default-date-text {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 6px 10px;\n    border-radius: 0.25rem;\n    // border: 1px solid var(--brd);\n    box-shadow: 0 0 0 1px var(--brd);\n\n    input {\n      outline: 0;\n      font-weight: 600;\n      color: #555;\n    }\n  }\n}\n.calender-wrapper1 {\n  position: absolute;\n  top: 100%;\n  margin-top: 10px;\n  background-color: var(--bgc);\n  z-index: 9999;\n  box-shadow: var(--depth-bs);\n  border-radius: 14px;\n}\n</style>\n","<script setup>\nimport { ref } from 'vue'\ndefineProps({\n  surface: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  float: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'left',\n  },\n  round: {\n    type: String,\n    default: 'l',\n  },\n  attached: {\n    type: Array,\n    default: null,\n  },\n  collapse: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst showDetail = ref(false)\nconst toggleCollapse = () => {\n  showDetail.value = !showDetail.value\n}\n</script>\n\n<template>\n  <div\n    class=\"be-segment\"\n    :class=\"[\n      { surface, border, float, attached: attached, collapse },\n      { detail: showDetail },\n      `align-${align}`,\n      `round-${round}`,\n    ]\"\n  >\n    <div v-if=\"attached && attached.includes('header')\" class=\"header\">\n      <slot name=\"header\"></slot>\n    </div>\n    <div class=\"contents\">\n      <slot></slot>\n    </div>\n    <div v-if=\"attached && attached.includes('footer')\" class=\"footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n    <div v-if=\"collapse\" class=\"toggle-detail\" @click=\"toggleCollapse\"></div>\n  </div>\n</template>\n","<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst elRef = ref(null)\n\nonMounted(() => {\n  if (!elRef.value.parentNode.style.position) {\n    elRef.value.parentNode.style.position = 'relative'\n  }\n})\ndefineProps({\n  content: {\n    type: [String, Number],\n  },\n  mark: {\n    type: Boolean,\n    default: false,\n  },\n  shadow: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'center',\n  },\n  color: {\n    type: String,\n    default: null,\n  },\n})\n</script>\n<template>\n  <div\n    class=\"be-badge\"\n    :class=\"[{ shadow, mark }, `align-${align}`, color]\"\n    ref=\"elRef\"\n  >\n    <slot>{{ content }}</slot>\n  </div>\n</template>\n","<script setup>\ndefineProps({\n  tabList: {\n    type: Array,\n    default: null,\n  },\n  vertical: {\n    type: Boolean,\n    default: false,\n  },\n  tabType: {\n    type: String,\n    default: null,\n  },\n})\n\nconst selectedTab = defineModel()\nconst emits = defineEmits(['remove'])\n\nconst removeTab = (tab) => {\n  emits('remove', tab)\n}\n</script>\n\n<template>\n  <div class=\"be-tabs\" :class=\"[{ vertical }, tabType]\">\n    <div class=\"tab-menu\">\n      <div\n        class=\"tab-item tab\"\n        v-for=\"tab in tabList\"\n        :key=\"tab\"\n        :class=\"{ active: tab.option === selectedTab }\"\n        @click=\"selectedTab = tab.option\"\n      >\n        <template v-if=\"tabType === 'browser'\">\n          <div class=\"tabText ellipsis\">{{ tab.option }}</div>\n          <div class=\"btn-close\" @click=\"() => removeTab(tab)\">\n            <i class=\"icon xi-close\" />\n          </div>\n        </template>\n        <template v-else>\n          {{ tab.option }}\n        </template>\n      </div>\n    </div>\n    <div class=\"tab-contents\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n","<script setup>\nimport { ref, computed, watch, onMounted } from 'vue'\nconst props = defineProps({\n  id: [String, Number],\n  trackType: {\n    type: String,\n    default: 'normal', // thin, normal, fat\n  },\n  min: {\n    type: Number,\n    default: 0,\n  },\n  max: {\n    type: Number,\n    default: 100,\n  },\n  unitText: [String, Object],\n  showStep: {\n    type: Boolean,\n    default: false,\n  },\n  stepSize: {\n    type: Number,\n    default: 10,\n  },\n  showLabel: {\n    type: Boolean,\n    default: false,\n  },\n  showValue: {\n    type: Boolean,\n    default: false,\n  },\n  showTooltip: {\n    type: Boolean,\n    default: false,\n  },\n  titleText: {\n    type: String,\n    default: null,\n  },\n  disabled: Boolean,\n  color: {\n    type: String,\n    default: '',\n  },\n})\n\nconst emit = defineEmits(['error'])\nconst resultValue = defineModel(0)\nconst result = ref(0)\n\nconst slider = ref(null)\nconst resultRef = ref(null)\n\nconst container = ref(500)\nconst initialX = ref(null)\nconst initialW = ref(null)\nconst catching = ref(false)\n\nconst startValue = ref(0)\n\nconst setResult = computed(() => ({\n  width: `${result.value}px`,\n  left: `${startValue.value}%`,\n}))\nconst setPosition = computed(() => ({ left: `${result.value}px` }))\n\nconst setResultValue = computed(() => {\n  return (\n    Math.ceil((props.max - props.min) * (result.value / container.value)) +\n    props.min\n  )\n})\n\nconst stepLevel = computed(() => (props.max - props.min) / props.stepSize)\nconst unitSize = computed(() => 100 / stepLevel.value)\n\nconst initValue = () => {\n  if (resultValue.value > props.max) {\n    emit('error', {\n      title: 'errorMaxValue',\n      message: `입력값이 ${props.max}보다 클 수 없습니다.`,\n    })\n    result.value = convertPixel(props.max)\n  } else if (resultValue.value < props.min) {\n    emit('error', {\n      title: 'errorMinValue',\n      message: `입력값이 ${props.max}보다 작을 수 없습니다.`,\n    })\n    result.value = convertPixel(props.min)\n  } else {\n    result.value = convertPixel(resultValue.value)\n  }\n}\nconst convertPercent = (value) => {\n  return (value - props.min) / (props.max - props.min)\n}\nconst convertPixel = (value) => {\n  return container.value * convertPercent(value)\n}\n\nconst updatePos = (distance) => {\n  let offset = initialW.value + distance\n  if (offset < 0) {\n    return 0\n  } else if (offset > container.value) {\n    return container.value\n  } else {\n    return offset\n  }\n}\n\nconst setStateOn = ({ target: control, pageX }) => {\n  if (control.classList.contains('control-btn')) {\n    initialX.value = pageX\n    initialW.value = resultRef.value.offsetWidth\n    catching.value = true\n    window.addEventListener('mousemove', changeValue)\n    window.addEventListener('mouseup', setStateOff)\n  } else {\n    result.value = updatePos(pageX - initialX.value)\n  }\n}\n\nconst setStateOff = ({ target: control, pageX }) => {\n  if (control.classList.contains('control-btn')) {\n    result.value = updatePos(pageX - initialX.value)\n  }\n  resultValue.value = setResultValue.value\n  catching.value = false\n  window.removeEventListener('mousemove', changeValue)\n  window.removeEventListener('mouseup', setStateOff)\n}\n\nconst changeValue = ({ pageX }) => {\n  result.value = updatePos(pageX - initialX.value)\n}\n\nconst selectStep = ({ target: step }) => {\n  console.log(step)\n}\nwatch(\n  resultValue,\n  () => {\n    initValue()\n  },\n  { immediate: true },\n)\n\nonMounted(() => {\n  if (slider.value) {\n    const sliderInfo = slider.value.getBoundingClientRect()\n    container.value = sliderInfo.width\n    initialX.value = sliderInfo.left\n\n    initValue()\n    slide_obs.observe(slider.value)\n  }\n})\n\nlet slide_obs = new ResizeObserver((entries) => {\n  for (let entry of entries) {\n    const entInfo = entry.contentRect\n    container.value = entInfo.width\n    initValue()\n  }\n})\n</script>\n\n<template>\n  <div\n    class=\"be-slider\"\n    ref=\"slider\"\n    :class=\"[{ disabled }, trackType, { labeled: showLabel }]\"\n    @mousedown=\"setStateOn\"\n    @mouseup=\"setStateOff\"\n  >\n    <div\n      class=\"result-slider primary\"\n      :class=\"`be-${color}`\"\n      ref=\"resultRef\"\n      :style=\"setResult\"\n    ></div>\n    <template v-if=\"showStep\">\n      <div\n        class=\"break-point\"\n        v-for=\"point in stepLevel - 1\"\n        :key=\"point\"\n        :style=\"{ left: `${point * unitSize}%` }\"\n        @click.stop=\"selectStep\"\n      ></div>\n    </template>\n    <div class=\"control-btn\" :class=\"{ catching }\" :style=\"setPosition\">\n      <div v-if=\"showTooltip\" class=\"tooltip\">\n        {{ setResultValue }}{{ unitText }}\n      </div>\n    </div>\n    <div v-if=\"showValue\" class=\"label-text\">\n      <div class=\"current-label\" :style=\"{ left: `${result}px` }\">\n        {{ setResultValue }}{{ unitText }}\n      </div>\n    </div>\n    <div v-if=\"showLabel\" class=\"label-text\">\n      <div class=\"start-label\">{{ min }}{{ unitText }}</div>\n      <div class=\"end-label\">{{ max }}{{ unitText }}</div>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped></style>\n","import './beui/beui.scss'\nimport * as components from './components'\n\nconst install = (app) => {\n  // 모든 컴포넌트를 순회하면서 등록\n  Object.entries(components).forEach(([name, component]) => {\n    // 컴포넌트 이름 정규화\n    const componentName = name.startsWith('Be') ? name : `Be${name}`\n    app.component(componentName, component)\n  })\n}\n\n// 컴포넌트 개별 export\nexport * from './components'\n\n// 기본 플러그인 export\nexport default {\n  install,\n  // 개별 컴포넌트도 함께 export\n  ...components,\n}\n"],"names":["emit","__emit","onClick","e","selectedIndex","_useModel","__props","handleSelect","idx","props","inputValue","isFocus","ref","input","iconPosition","computed","checkFocus","onBlur","onMounted","increase","decrease","keyControl","event","checkedValue","uniqueId","selectedValue","checkboxList","val","c","selectCheck","i","selectedRadio","selectItem","statusIcon","iconName","pageEl","current","last","pageList","offLimits","n","start","half","isPrevPoint","isNextPoint","findStart","isDisabledNext","isDisabledPrev","vue","nextTick","setCurrent","num","setPrev","setNext","setPrevBlock","prevNum","setNextBlock","isOpen","iconClass","setHeight","showPanel","setValue","rate","result","isHalf","isFloat","setFloat","percent","onHover","targetPos","onMove","onLeave","setRate","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","value","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","yAxisSides","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","lrPlacement","rlPlacement","tbPlacement","btPlacement","getSideList","side","isStart","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","name","fn","nextX","nextY","data","reset","detectOverflow","state","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","sides","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","d","resetPlacement","a","b","_overflowsData$filter2","currentSideAxis","acc","originSides","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","offset","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","hasWindow","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isHTMLElement","isShadowRoot","invalidOverflowDisplayValues","isOverflowElement","overflowX","overflowY","display","getComputedStyle","tableElements","isTableElement","topLayerSelectors","isTopLayer","selector","transformProperties","willChangeValues","containValues","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","lastTraversableNodeNames","getNodeScroll","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","ignoreScrollbarX","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","offsets","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","getViewportRect","visualViewport","visualViewportBased","absoluteOrFixed","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","setLeftRTLScrollbarOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","rectsAreEqual","observeMove","io","timeoutId","root","cleanup","_io","refresh","skip","threshold","elementRectForRootMargin","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","mergedOptions","platformWithCache","computePosition$1","isComponentPublicInstance","target","toValue","source","unref","getDPR","roundByDPR","dpr","useFloating","whileElementsMountedOption","openOption","_toValue","middlewareOption","placementOption","_toValue2","strategyOption","_toValue3","transformOption","_toValue4","referenceElement","floatingElement","shallowRef","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","open","position","attach","watch","getCurrentScope","onScopeDispose","shallowReadonly","elRef","menu","isShow","selectedItem","selectedList","optionList","reactive","searchText","offsetValue","customFloatingStyle","floatOffset","selectedText","selectIndex","t","searchedOptions","f","item","optionsHeight","initValue","showMenu","onUnmounted","menuPos","setMenuStyle","posEl","toggleOpen","setMultipleList","_a","_b","same","selectAll","se","switchValue","selectedRow","gridClass","setSelect","row","showNode","checked","toggleNode","lastDayList","week_en_m","MONTH_TEXT_LIST","getDateInfo","date","newDate","m","getStartDay","year","month","startIndex","basicDay","leafDay","currentYearDay","setCalendar","now","startDay","dayList","currLast","prevLast","currDay","nextDay","j","cell","week","emits","currentDate","selectDate","cellRows","newValue","setDayList","prevMonth","nextMonth","setSelectDate","checkSelectDate","setToday","setSelectedData","payload","formattedDate","dateValue","day","menuStyle","showDetail","toggleCollapse","selectedTab","removeTab","tab","resultValue","slider","resultRef","container","initialX","initialW","catching","startValue","setResult","setPosition","setResultValue","stepLevel","unitSize","convertPixel","convertPercent","updatePos","distance","setStateOn","control","pageX","changeValue","setStateOff","selectStep","step","sliderInfo","slide_obs","entry","entInfo","index","app","components","component","componentName"],"mappings":"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","x_google_ignoreList":[13,14,15,16,17]}