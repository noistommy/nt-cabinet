{
  "version": 3,
  "sources": ["../../../node_modules/noist-beui/src/components/button/BeButton.vue", "../../../node_modules/noist-beui/src/components/button/BeButtons.vue", "../../../node_modules/noist-beui/src/components/input/BeInput.vue", "../../../node_modules/noist-beui/src/components/input/BeInputNumber.vue", "../../../node_modules/noist-beui/src/components/checkbox/BeCheckBox.vue", "../../../node_modules/noist-beui/src/components/checkbox/BeCheckBoxGroup.vue", "../../../node_modules/noist-beui/src/components/checkbox/BeRadio.vue", "../../../node_modules/noist-beui/src/components/list/BeList.vue", "../../../node_modules/noist-beui/src/components/message/BeMessage.vue", "../../../node_modules/noist-beui/src/components/pagination/BePagination.vue", "../../../node_modules/noist-beui/src/components/panel/BePanel.vue", "../../../node_modules/noist-beui/src/components/radio/BeRadios.vue", "../../../node_modules/noist-beui/src/components/rate/BeRate.vue", "../../../node_modules/noist-beui/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../node_modules/noist-beui/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../node_modules/noist-beui/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../../node_modules/noist-beui/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../node_modules/noist-beui/node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs", "../../../node_modules/noist-beui/src/components/selectbox/BeSelectBox.vue", "../../../node_modules/noist-beui/src/components/switch/BeSwitch.vue", "../../../node_modules/noist-beui/src/components/table/BeTable.vue", "../../../node_modules/noist-beui/src/components/tree/BeTreeNode.vue", "../../../node_modules/noist-beui/src/components/calendar/calendar.js", "../../../node_modules/noist-beui/src/components/calendar/BeCalendar.vue", "../../../node_modules/noist-beui/src/components/calendar/BeDatePicker.vue", "../../../node_modules/noist-beui/src/components/segment/BeSegment.vue", "../../../node_modules/noist-beui/src/components/tag/BeBadge.vue", "../../../node_modules/noist-beui/src/components/tabs/BeTabs.vue", "../../../node_modules/noist-beui/src/components/slider/BeSlider.vue", "../../../node_modules/noist-beui/src/index.js"],
  "sourcesContent": ["<script setup>\ndefineProps({\n  contentText: {\n    type: String,\n    default: '',\n  },\n  brand: {\n    type: String,\n  },\n  status: {\n    type: String,\n  },\n  color: {\n    type: String,\n  },\n  text: {\n    type: Boolean,\n  },\n  border: {\n    type: Boolean,\n  },\n  disabled: {\n    type: Boolean,\n  },\n  fluid: {\n    type: Boolean,\n  },\n  round: {\n    type: Boolean,\n  },\n  compact: {\n    type: Boolean,\n  },\n  outline: {\n    type: Boolean,\n  },\n  icon: {\n    type: Boolean,\n  },\n  withIcon: {\n    type: String,\n    default: null,\n  },\n  iconPos: {\n    type: String,\n  },\n  badge: {\n    type: String,\n  },\n  badgeOption: {\n    type: String,\n  },\n  link: {\n    type: String,\n    default: null,\n  },\n  linkTarget: {\n    type: String,\n    default: null,\n  },\n})\nconst emit = defineEmits(['onClick'])\nconst onClick = (e) => {\n  emit('onClick', e)\n}\n</script>\n\n<template>\n  <button\n    class=\"be-button\"\n    :class=\"[\n      brand,\n      status,\n      color,\n      { text },\n      { link },\n      { border },\n      { disabled },\n      { fluid },\n      { round },\n      { compact },\n      { outline },\n      { icon },\n      { badge: badge },\n    ]\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <template v-if=\"withIcon && (iconPos === 'left' || iconPos === 'both')\">\n        <i class=\"icon\" :class=\"[iconPos, withIcon]\"></i>\n      </template>\n      <template v-if=\"icon\">\n        <i class=\"icon\" :class=\"icon\"></i>\n      </template>\n      {{ contentText }}\n      <template\n        v-if=\"withIcon && (iconPos === 'right' || iconPos === 'both')\"\n      ></template>\n      <template v-if=\"badge\">\n        <div class=\"in-badge\" :class=\"badgeOption\">{{ badge }}</div>\n      </template>\n    </slot>\n    <a v-if=\"link\" :href=\"link\" :target=\"linkTarget || '_self'\" />\n  </button>\n</template>\n", "<script setup>\nimport BeButton from './BeButton.vue'\n\ndefineProps({\n  buttons: {\n    type: Array,\n    required: true,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst selectedIndex = defineModel()\n\nconst handleSelect = (idx) => {\n  selectedIndex.value = idx\n}\n</script>\n\n<template>\n  <div class=\"be-buttons\">\n    <slot>\n      <template v-for=\"(btn, i) in buttons\" :key=\"`btn-${i}`\">\n        <BeButton\n          v-bind=\"btn.option\"\n          @click=\"() => handleSelect(i)\"\n          :class=\"{ selected: selectedIndex === i }\"\n        ></BeButton>\n      </template>\n    </slot>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed } from 'vue'\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'input',\n    validator(value) {\n      return ['input', 'textarea'].includes(value)\n    },\n  },\n  inputType: {\n    type: String,\n    default: 'text',\n  },\n  align: {\n    type: String,\n    default: 'left',\n    validator(value) {\n      return ['left', 'center', 'right'].includes(value)\n    },\n  },\n  status: {\n    type: String,\n    default: null,\n    validator(value) {\n      return ['success', 'error', 'attention', 'info', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  placeholder: {\n    type: String,\n    default: '입력하세요',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  underline: {\n    type: Boolean,\n    default: false,\n  },\n  transparent: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  iconLeft: {\n    type: String,\n    default: null,\n  },\n  iconRight: {\n    type: String,\n    default: null,\n  },\n  clear: {\n    type: Boolean,\n    default: false,\n  },\n  badge: {\n    type: String,\n    default: null,\n  },\n  badgeOption: {\n    type: String,\n    default: null,\n  },\n  edit: {\n    type: Boolean,\n    default: false,\n  },\n  editMode: {\n    type: Boolean,\n    default: false,\n  },\n  unit: {\n    type: String,\n    default: null,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst inputValue = defineModel()\nconst emit = defineEmits(['focus'])\n\nconst isFocus = ref(false)\n\nconst input = ref(null)\nconst iconPosition = computed(() => {\n  if (props.iconLeft && (props.iconRight || props.clear)) return 'both'\n  return props.iconLeft\n    ? 'left'\n    : props.iconRight || props.clear\n      ? 'right'\n      : null\n})\n\nconst checkFocus = () => {\n  if (!isFocus.value) {\n    isFocus.value = true\n    console.log('fucus', isFocus.value)\n    emit('focus', isFocus.value)\n  }\n}\nconst onBlur = () => {\n  isFocus.value = false\n  emit('focus', isFocus.value)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-input\"\n    :class=\"[\n      status,\n      { readonly },\n      { underline },\n      { round },\n      { transparent },\n      { compact },\n      { fluid },\n      { edit: edit },\n      { editable: editMode },\n      { icon: iconLeft || iconRight || clear },\n      iconPosition,\n      { badge: badge },\n      { unit },\n      { disabled },\n    ]\"\n    :data-unit=\"unit\"\n  >\n    <slot>\n      <i v-if=\"iconLeft\" :class=\"`icon xi-${iconLeft}`\" />\n      <template v-if=\"type === 'input'\">\n        <input\n          :type=\"inputType\"\n          v-model=\"inputValue\"\n          :placeholder=\"placeholder\"\n          :class=\"[`aline-${align}`]\"\n          ref=\"input\"\n          :disabled=\"disabled\"\n          :readonly=\"readonly\"\n          @click=\"checkFocus()\"\n          @blur=\"onBlur()\"\n        />\n      </template>\n      <template v-else>\n        <textarea\n          v-model=\"inputValue\"\n          rows=\"3\"\n          :placeholder=\"placeholder\"\n        ></textarea>\n      </template>\n\n      <i\n        v-if=\"clear\"\n        class=\"icon clear-btn xi-close\"\n        :class=\"{ disabled: inputValue === '' }\"\n        @click=\"inputValue = ''\"\n      />\n      <i v-else-if=\"iconRight && !clear\" :class=\"`icon xi-${iconRight}`\" />\n      <span v-else-if=\"badge\" class=\"be-badge\" :class=\"badgeOption\">{{\n        badge\n      }}</span>\n    </slot>\n  </div>\n</template>\n", "<script setup>\nimport { ref, onMounted } from 'vue'\nconst props = defineProps({\n  status: {\n    type: String,\n    default: null,\n    validator(value) {\n      return ['success', 'error', 'attention', 'info', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  placeholder: {\n    type: String,\n    default: '',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  iconLeft: {\n    type: String,\n    default: null,\n  },\n  iconRight: {\n    type: String,\n    default: null,\n  },\n  step: {\n    type: Number,\n    default: 1,\n  },\n  controller: {\n    type: String,\n    default: 'between',\n  },\n  min: {\n    type: Number,\n  },\n  max: {\n    type: Number,\n  },\n  incIcon: {\n    type: String,\n    default: 'xi-plus',\n  },\n  decIcon: {\n    type: String,\n    default: 'xi-minus',\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst inputValue = defineModel()\nconst emit = defineEmits(['focus'])\n\nconst isFocus = ref(false)\n\nconst input = ref(null)\n\nonMounted(() => {\n  if (inputValue.value < props.min) inputValue.value = props.min\n  if (inputValue.value > props.max) inputValue.value = props.max\n})\nconst checkFocus = () => {\n  if (!isFocus.value) {\n    isFocus.value = true\n    console.log('fucus', isFocus.value)\n    emit('focus', isFocus.value)\n  }\n}\nconst onBlur = () => {\n  isFocus.value = false\n  emit('focus', isFocus.value)\n}\nconst increase = () => {\n  if (inputValue.value + props.step > props.max) return\n  inputValue.value += props.step\n}\nconst decrease = () => {\n  if (inputValue.value - props.step < props.min) return\n  inputValue.value -= props.step\n}\nconst keyControl = (event) => {\n  if (props.disabled) return\n  if (event.keyCode === 38) increase()\n  if (event.keyCode === 40) decrease()\n}\n</script>\n\n<template>\n  <div\n    class=\"be-input button number\"\n    :class=\"[status, { readonly, compact, fluid, disabled, round }, controller]\"\n    tabindex=\"-1\"\n    @keydown.prevent=\"keyControl\"\n  >\n    <slot>\n      <input\n        type=\"number\"\n        v-model=\"inputValue\"\n        ref=\"input\"\n        @click=\"checkFocus()\"\n        @blur=\"onBlur()\"\n      />\n    </slot>\n    <button class=\"be-button icon dec\" :class=\"{ disabled }\" @click=\"decrease\">\n      <i class=\"icon\" :class=\"decIcon\"></i>\n    </button>\n    <button class=\"be-button icon inc\" :class=\"{ disabled }\" @click=\"increase\">\n      <i class=\"icon\" :class=\"incIcon\"></i>\n    </button>\n  </div>\n</template>\n", "<script setup>\ndefineProps({\n  type: {\n    type: String,\n    default: 'checkbox',\n    varidator: (value) => {\n      return ['checkbox', 'radio'].includes(value)\n    },\n  },\n  name: {\n    type: String,\n  },\n  labelText: {\n    type: String,\n    default: null,\n  },\n  indeter: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst checkedValue = defineModel()\n</script>\n\n<template>\n  <div\n    class=\"be-checkbox\"\n    :class=\"[type, { checked: checkedValue }, { indeter }]\"\n    @click=\"checkedValue = !checkedValue\"\n  >\n    <input type=\"checkbox\" :name=\"name\" v-model=\"checkedValue\" />\n    <label>\n      {{ labelText }}\n    </label>\n  </div>\n</template>\n", "<script setup>\nimport { ref, onMounted } from 'vue'\nconst props = defineProps({\n  checkList: {\n    type: Array,\n    required: true,\n  },\n})\nconst uniqueId = Math.random().toString(36)\n\nconst emit = defineEmits(['result'])\nconst selectedValue = defineModel('result')\n\nconst checkboxList = ref(new Array(props.checkList.length).fill(false))\n\nonMounted(() => {\n  selectedValue.value.forEach((val) => {\n    const idx = props.checkList.findIndex((c) => c === val)\n    checkboxList.value[idx] = true\n  })\n})\nconst selectCheck = () => {\n  selectedValue.value = props.checkList.filter((c, i) => checkboxList.value[i])\n  emit('result', selectedValue.value)\n  // emit('select-value', checkboxList.value.filter(cb => cb.value))\n}\n</script>\n\n<template>\n  <div class=\"be-checkout-group\">\n    <div\n      v-for=\"(item, i) in checkList\"\n      :key=\"item\"\n      class=\"be-checkbox\"\n      :class=\"{ checked: checkboxList[i] }\"\n    >\n      <input\n        type=\"checkbox\"\n        :id=\"`${item}-${uniqueId}`\"\n        v-model=\"checkboxList[i]\"\n        @change=\"selectCheck\"\n      />\n      <label :for=\"`${item}-${uniqueId}`\">{{ item }}</label>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-checkout-group {\n  display: flex;\n}\n</style>\n", "<script setup>\ndefineProps({\n  optionList: {\n    type: Array,\n    required: true,\n  },\n  selected: {\n    type: String,\n    default: '',\n  },\n})\nconst uniqueId = Math.random().toString(36)\n\nconst emit = defineEmits(['result'])\nconst selectedRadio = defineModel('result')\n\nconst selectCheck = () => {\n  emit('result', selectedRadio.value)\n}\n</script>\n\n<template>\n  <div class=\"be-radio\">\n    <div\n      v-for=\"item in optionList\"\n      :key=\"item\"\n      class=\"be-checkbox radio\"\n      :class=\"{ checked: item === selectedRadio }\"\n    >\n      <input\n        type=\"radio\"\n        :id=\"`${item}-${uniqueId}`\"\n        v-model=\"selectedRadio\"\n        :value=\"item\"\n        @change=\"selectCheck\"\n      />\n      <label :for=\"`${item}-${uniqueId}`\">{{ item }}</label>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-radio {\n  display: flex;\n}\n</style>\n", "<script setup>\ndefineProps({\n  options: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  selection: {\n    type: Boolean,\n    default: false,\n  },\n  selectedType: {\n    type: String,\n    default: 'bg',\n  },\n  icon: {\n    type: Boolean,\n    default: false,\n  },\n  image: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst selectItem = defineModel()\n</script>\n\n<template>\n  <div class=\"be-list\" :class=\"[{ selection }, { border }, selectedType]\">\n    <div\n      class=\"item\"\n      v-for=\"opt in options\"\n      :key=\"opt.option\"\n      :class=\"{ selected: selectItem && selectItem.option === opt.option }\"\n      @click=\"selectItem = opt\"\n    >\n      <template v-if=\"image\">\n        <div class=\"item-img\">\n          <img :src=\"opt.image\" />\n        </div>\n      </template>\n      <template v-else-if=\"icon\">\n        <i class=\"list-icon icon\" :class=\"opt.icon\" />\n      </template>\n      <div class=\"item-title\">\n        {{ opt.option }}\n        <div class=\"sub-title\" v-if=\"opt.sub\">\n          {{ opt.sub }}\n        </div>\n      </div>\n      <template v-if=\"button\">\n        <div class=\"btn-set\">\n          <div class=\"be-button round icon\">\n            <i :Class=\"opt.icon\"></i>\n          </div>\n        </div>\n      </template>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\n\nconst statusIcon = {\n  success: 'xi-check-circle',\n  info: 'xi-info',\n  error: 'xi-emoticon-devil',\n  attention: 'xi-warning',\n  importance: 'xi-star',\n}\n\nconst props = defineProps({\n  title: {\n    type: String,\n  },\n  contents: {\n    type: String,\n  },\n  icon: {\n    type: String,\n  },\n  status: {\n    type: String,\n    default: null,\n    varidator: (value) => {\n      return ['success', 'error', 'info', 'attention', 'importance'].includes(\n        value,\n      )\n    },\n  },\n  selected: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst iconName = computed(() => {\n  if (props.status) {\n    return statusIcon[props.status]\n  } else {\n    return props.icon\n  }\n})\n</script>\n\n<template>\n  <div\n    class=\"be-message\"\n    :class=\"[{ icon: icon }, status, { selected, disabled }]\"\n  >\n    <template v-if=\"icon\">\n      <i class=\"icon\" :class=\"iconName\" />\n    </template>\n    <slot>\n      <div class=\"title\">{{ title }}</div>\n      <div class=\"contents\">{{ contents }}</div>\n    </slot>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed, watch, onMounted, nextTick } from 'vue'\n\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'number',\n    varidator: (value) => {\n      return ['number', 'page'].includes(value)\n    },\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n  compact: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'left',\n  },\n  limits: {\n    type: Number,\n    default: 5,\n  },\n  currentPage: {\n    type: Number,\n    default: 1,\n  },\n  pageLength: {\n    type: Number,\n    default: 1,\n  },\n  itemClass: {\n    type: String,\n  },\n  ellipsis: {\n    type: Boolean,\n    default: false,\n  },\n  color: {\n    type: String,\n  },\n  firstText: {\n    type: String,\n    default: 'F',\n  },\n  lastText: {\n    type: String,\n    default: 'L',\n  },\n  activeType: {\n    type: String,\n    default: 'button', // text\n  },\n})\nconst pageEl = ref(null)\nconst current = defineModel()\nconst emit = defineEmits(['change'])\nconst last = ref(1)\n\nconst pageList = computed(() => {\n  if (offLimits.value) {\n    return new Array(props.pageLength).fill(1).map((n, i) => n + i)\n  } else if (props.ellipsis) {\n    let start = 2\n    let half = Math.floor(props.limits / 2)\n    if (isPrevPoint.value) {\n      start = current.value - half\n    }\n    if (!isNextPoint.value && isPrevPoint.value) {\n      start = last.value - props.limits\n    }\n    return new Array(props.limits).fill(0).map((n, i) => start + i)\n  } else {\n    let start = Math.min(findStart.value, props.pageLength - props.limits + 1)\n    return new Array(props.limits).fill(start).map((n, i) => n + i)\n  }\n})\nconst findStart = computed(() => {\n  return Math.max(current.value - Math.ceil(props.limits * 0.5) + 1, 1)\n})\n// const isSingle = computed(() => {\n//   return props.pageLength === 1\n// })\nconst isPrevPoint = computed(() => {\n  return (\n    current.value > Math.floor(props.limits / 2) + 2 &&\n    props.limits < last.value\n  )\n})\nconst isNextPoint = computed(() => {\n  return current.value <= last.value - props.limits && props.limits < last.value\n})\nconst isDisabledNext = computed(() => {\n  return current.value + 1 > last.value\n})\nconst isDisabledPrev = computed(() => {\n  return current.value - 1 <= 0\n})\nconst offLimits = computed(() => {\n  return props.pageLength <= props.limits || !props.limits\n})\n\nwatch(props, () => {\n  last.value = props.pageLength\n})\n\nonMounted(async () => {\n  await nextTick()\n  pageEl.value.focus()\n  // current.value = props.currentPage\n  last.value = props.pageLength\n})\n\nconst setCurrent = (num) => {\n  if (num > last.value || num <= 0) return\n  current.value = num\n  emit('change', num)\n}\nconst setPrev = () => {\n  if (isDisabledPrev.value) return\n  setCurrent(current.value - 1)\n}\nconst setNext = () => {\n  if (isDisabledNext.value) return\n  setCurrent(current.value + 1)\n}\nconst setPrevBlock = () => {\n  let prevNum =\n    current.value - props.limits <= 0\n      ? current.value - 1\n      : current.value - props.limits\n  setCurrent(prevNum)\n}\nconst setNextBlock = () => {\n  let prevNum =\n    current.value + props.limits > last.value\n      ? current.value + 1\n      : current.value + props.limits\n  setCurrent(prevNum)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-pagination\"\n    :class=\"[type, activeType, { round }, { compact }, `align-${align}`, color]\"\n    ref=\"pageEl\"\n  >\n    <div\n      v-if=\"!ellipsis && !offLimits\"\n      class=\"pagination-nav first\"\n      :class=\"[itemClass, { disabled: isDisabledPrev }]\"\n      @click=\"setCurrent(1)\"\n    >\n      <template v-if=\"firstText.indexOf('xi-') > -1\">\n        <i :class=\"firstText\" />\n      </template>\n      <template v-else>{{ firstText }}</template>\n    </div>\n    <div\n      class=\"pagination-nav prev\"\n      :class=\"[itemClass, { disabled: isDisabledPrev }]\"\n      @click=\"setPrev\"\n    >\n      <i class=\"xi-angle-left\"></i>\n    </div>\n    <template v-if=\"ellipsis\">\n      <div\n        class=\"pagination-num\"\n        :class=\"[itemClass, { active: 1 === current }]\"\n        @click=\"setCurrent(1)\"\n      >\n        1\n      </div>\n      <div\n        v-if=\"isPrevPoint\"\n        class=\"pagination-num\"\n        :class=\"[itemClass]\"\n        @click=\"setPrevBlock\"\n      >\n        <i class=\"xi-ellipsis-h\"></i>\n      </div>\n    </template>\n    <div class=\"pagination-page-wrapper\">\n      <template v-if=\"type === 'number'\">\n        <div\n          class=\"pagination-num\"\n          v-for=\"page in pageList\"\n          :key=\"page\"\n          :class=\"[itemClass, { active: page === current }]\"\n          @click=\"setCurrent(page)\"\n        >\n          {{ page }}\n        </div>\n      </template>\n      <template v-else>\n        <div class=\"pagination-info\">\n          <div class=\"pagination-nav current\">{{ current }}</div>\n          <span class=\"slash\">/</span>\n          <div class=\"pagination-nav\" last>{{ last }}</div>\n        </div>\n      </template>\n    </div>\n    <template v-if=\"ellipsis && props.limits < props.pageLength\">\n      <div\n        v-if=\"isNextPoint\"\n        class=\"pagination-nav\"\n        :class=\"[itemClass]\"\n        @click=\"setNextBlock\"\n      >\n        <i class=\"xi-ellipsis-h\"></i>\n      </div>\n      <div\n        class=\"pagination-num\"\n        :class=\"[itemClass, { active: last === current }]\"\n        @click=\"setCurrent(last)\"\n      >\n        {{ last }}\n      </div>\n    </template>\n    <div\n      class=\"pagination-nav next\"\n      :class=\"[itemClass, { disabled: isDisabledNext }]\"\n      @click=\"setNext\"\n    >\n      <i class=\"xi-angle-right\"></i>\n    </div>\n    <div\n      v-if=\"!ellipsis && !offLimits\"\n      class=\"pagination-nav last\"\n      :class=\"[itemClass, { disabled: isDisabledNext }]\"\n      @click=\"setCurrent(last)\"\n    >\n      <template v-if=\"lastText.indexOf('xi-') > -1\">\n        <i :class=\"lastText\" />\n      </template>\n      <template v-else>{{ lastText }}</template>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed } from 'vue'\nconst props = defineProps({\n  title: {\n    type: String,\n  },\n  contents: {\n    type: String,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  toggleIcon: {\n    type: String,\n    default: null,\n  },\n  iconPos: {\n    type: String,\n    default: 'left',\n  },\n  open: {\n    type: Boolean,\n    default: false,\n  },\n  collapse: {\n    type: Boolean,\n    default: false,\n  },\n  maxHeight: {\n    type: Number,\n    default: 200,\n  },\n})\n\nconst emit = defineEmits(['show'])\nconst isOpen = ref(props.open)\nconst iconClass = computed(() => {\n  if (!props.toggleIcon && props.collapse) return ''\n  return `icon ${props.iconPos}`\n})\n\nconst setHeight = computed(() => {\n  if (!props.collapse) return {}\n  return {\n    '--max-height': `${props.maxHeight}px`,\n  }\n})\n\nconst showPanel = () => {\n  if (!props.collapse) return\n  isOpen.value = !isOpen.value\n  emit('show', isOpen.value)\n}\n</script>\n<template>\n  <div\n    class=\"be-panel\"\n    :class=\"[{ border, collapse }, iconClass, { open: isOpen }]\"\n  >\n    <div class=\"panel-header\" @click=\"showPanel\">\n      <div class=\"title\">{{ title }}</div>\n      <span v-if=\"collapse && toggleIcon\">\n        <i class=\"icon\" :class=\"`${toggleIcon}`\"></i>\n      </span>\n    </div>\n    <div class=\"panel-content\" :style=\"setHeight\">\n      <div class=\"content-wrapper\">\n        <slot name=\"contents\">\n          {{ contents }}\n        </slot>\n      </div>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { computed } from 'vue'\nconst props = defineProps({\n  type: {\n    type: String,\n    default: 'checkbox',\n    varidator: (value) => {\n      return ['checkbox', 'radio'].includes(value)\n    },\n  },\n  id: {\n    type: String,\n  },\n  name: {\n    type: String,\n  },\n  labelText: {\n    type: String,\n    default: '',\n  },\n})\n\nconst checkedValue = defineModel()\n\nconst setValue = computed(() => {\n  if (props.type === 'radio') {\n    return checkedValue.value === props.id\n  } else {\n    return checkedValue.value\n  }\n})\n</script>\n\n<template>\n  <div class=\"be-checkbox\" :class=\"[type, { checked: setValue }]\">\n    <input\n      :type=\"type\"\n      :name=\"name\"\n      :id=\"id\"\n      v-model=\"checkedValue\"\n      :value=\"id\"\n    />\n    <label :for=\"id\">\n      <slot>{{ labelText }}</slot>\n    </label>\n  </div>\n</template>\n", "<script setup>\nimport { ref, onMounted, computed, watch } from 'vue'\n\nconst props = defineProps({\n  rateLength: {\n    type: Number,\n    default: 5,\n  },\n  useHalf: {\n    type: Boolean,\n    default: false,\n  },\n  icon: {\n    type: String,\n    default: 'xi-star',\n  },\n  resultValue: {\n    type: Number,\n    default: 0,\n  },\n  size: {\n    type: String,\n    default: null,\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  color: {\n    type: String,\n    default: null,\n  },\n  border: {\n    type: Boolean,\n    default: true,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  clearable: {\n    type: Boolean,\n    default: true,\n  },\n})\n\nconst emit = defineEmits(['select'])\nconst rate = ref(0)\nconst result = ref(0)\nconst isHalf = ref(false)\nconst isFloat = ref(0)\n\nconst setFloat = computed(() => {\n  const percent = ((rate.value * 10) % 10) * 10\n  if (percent === 0) return {}\n  return {\n    width: `${percent}%`,\n    overflow: 'hidden',\n  }\n})\n\nwatch(\n  () => props.resultValue,\n  () => {\n    rate.value = props.resultValue\n    result.value = props.resultValue\n  },\n  { immediate: true },\n)\nonMounted(() => {\n  isFloat.value = ((rate.value * 10) % 10) * 10\n})\nconst onHover = (num) => {\n  if (props.useHalf) {\n    const targetPos = event.target.getBoundingClientRect()\n    isHalf.value = targetPos.left + targetPos.width / 2 - event.pageX > 0\n  }\n  rate.value = num\n}\n\nconst onMove = (num) => {\n  if (!props.useHalf) return\n  onHover(num)\n}\nconst onLeave = () => {\n  rate.value = result.value || 0\n}\n\nconst setRate = (num) => {\n  if (props.clearable) {\n    result.value = Math.ceil(result.value) === num ? 0 : result.value\n  }\n  result.value = result.value === num ? 0 : num\n  if (props.useHalf) {\n    result.value = isHalf.value ? num - 0.5 : num\n  }\n  emit('select', result.value)\n}\n</script>\n\n<template>\n  <div class=\"be-rate\" :class=\"[size, color, { readonly, disabled, border }]\">\n    <span\n      v-for=\"item in rateLength\"\n      :key=\"item\"\n      class=\"rate-item\"\n      :class=\"[\n        { check: Math.ceil(rate) >= item },\n        { half: Math.ceil(rate) === item && isHalf },\n      ]\"\n      @mouseenter=\"onHover(item)\"\n      @mouseleave=\"onLeave\"\n      @mousemove=\"onMove(item)\"\n      @click=\"setRate(item)\"\n    >\n      <i class=\"icon\" :class=\"`${icon}-o`\"></i>\n      <i\n        class=\"icon\"\n        :class=\"icon\"\n        :style=\"Math.ceil(rate) === item ? setFloat : null\"\n      ></i>\n    </span>\n  </div>\n</template>\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n", "import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\nfunction toValue(source) {\n  return typeof source === 'function' ? source() : unref(source);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(toValue(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _toValue;\n    return (_toValue = toValue(options.open)) != null ? _toValue : true;\n  });\n  const middlewareOption = computed(() => toValue(options.middleware));\n  const placementOption = computed(() => {\n    var _toValue2;\n    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _toValue3;\n    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _toValue4;\n    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    const open = openOption.value;\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      /**\n       * The floating element's position may be recomputed while it's closed\n       * but still mounted (such as when transitioning out). To ensure\n       * `isPositioned` will be `false` initially on the next open, avoid\n       * setting it to `true` when `open === false` (must be specified).\n       */\n      isPositioned.value = open !== false;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption, openOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n", "<script setup>\nimport { ref, reactive, computed, watch, onMounted, onUnmounted } from 'vue'\nimport { useFloating, autoUpdate, offset, flip, shift } from '@floating-ui/vue'\n\nconst props = defineProps({\n  target: {\n    type: String,\n  },\n  options: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  selectedValue: {\n    type: [Array, Object, String],\n    default: () => {\n      return null\n    },\n  },\n  boxType: {\n    type: String,\n    default: 'dropdown', // dropdown, float\n  },\n  placeholder: {\n    type: String,\n    default: '선택하세요',\n  },\n  isSearch: {\n    type: Boolean,\n    default: false,\n  },\n  useIcon: {\n    type: Boolean,\n    default: false,\n  },\n  multiple: {\n    type: Boolean,\n    default: false,\n  },\n  maxOptHeight: {\n    type: Number,\n    default: 260,\n  },\n  selectedType: {\n    type: String,\n    default: 'bg',\n  },\n  optionKey: {\n    type: String,\n    default: 'option',\n  },\n  resultKey: {\n    type: String,\n    default: 'val',\n  },\n  isAll: {\n    type: Boolean,\n    default: false,\n  },\n  fluid: {\n    type: Boolean,\n    default: false,\n  },\n  disabled: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emit = defineEmits(['select'])\n// const selectedValue = defineModel()\n\nconst elRef = ref(null)\nconst menu = ref(null)\nconst isShow = ref(false)\n\nconst reference = ref(null)\nconst floating = ref(null)\n\nconst selectedItem = ref(null)\nconst selectedList = ref([])\nconst optionList = reactive(props.options)\nconst searchText = ref(null)\n\nconst offsetValue = props.boxType === 'dropdown' ? 10 : 0\n\nconst { x, y, strategy, isPositioned } = useFloating(reference, floating, {\n  middleware: [offset(offsetValue), flip(), shift()],\n  whileElementsMounted: autoUpdate,\n})\n\nconst customFloatingStyle = computed(() => {\n  const floatOffset =\n    props.boxType === 'dropdown' ? 0 : (selectedIndex.value + 1) * -37\n  return {\n    position: strategy.value,\n    inset: `0 auto auto 0`,\n    transform: `translate(${x.value}px, ${y.value + floatOffset}px)`,\n  }\n})\n\nwatch(isPositioned, () => {\n  floating.value.focus()\n})\n\nconst selectedText = computed(() => {\n  if (props.multiple) {\n    return selectedList.value.length > 0\n      ? `${selectedList.value.length} 개 선택`\n      : null\n  } else {\n    const selectIndex = props.options.findIndex(\n      (t) => t[props.resultKey] === selectedItem.value,\n    )\n    return props.options[selectIndex]\n      ? props.options[selectIndex][props.optionKey]\n      : null\n  }\n})\n\nconst selectedIndex = computed(() => {\n  return selectedItem.value\n    ? searchedOptions.value.findIndex(\n        (f) => f[props.resultKey] === selectedItem.value,\n      )\n    : 0\n})\n\nconst searchedOptions = computed(() => {\n  if (props.isSearch && searchText.value && !props.multiple) {\n    return optionList.filter(\n      (item) =>\n        item[props.optionKey]\n          .toLowerCase()\n          .indexOf(searchText.value.toLowerCase()) > -1,\n    )\n  } else {\n    return optionList\n  }\n})\nconst optionsHeight = computed(() => {\n  if (!props.maxOptHeight) return\n  return { maxHeight: props.maxOptHeight + 'px' }\n})\n\nwatch(props, () => {\n  initValue()\n})\n\nonMounted(() => {\n  initValue()\n  window.addEventListener('click', () => showMenu(false))\n})\nonUnmounted(() => {\n  window.removeEventListener('click', () => showMenu(false))\n})\n\nconst initValue = () => {\n  if (props.multiple) {\n    selectedList.value = props.selectedValue ? props.selectedValue : []\n    selectedItem.value = props.selectedValue\n      ? `${props.selectedValue.length} 개 선택`\n      : null\n  } else {\n    selectedItem.value = props.selectedValue\n  }\n}\n\nconst menuPos = ref('down')\n\nconst setMenuStyle = computed(() => {\n  if (!isShow.value) return\n  const posEl = elRef.value.getBoundingClientRect()\n  if (menuPos.value === 'up') {\n    return {\n      width: posEl.width + 'px',\n      // top: posEl.top - (Number(props.maxOptHeight) + 10) + 'px',\n      // left: posEl.left + 'px',\n    }\n  } else {\n    return {\n      width: posEl.width + 'px',\n      // top:\n      //   props.boxType === 'dropdown'\n      //     ? posEl.bottom + 'px'\n      //     : posEl.top - selectedIndex.value * 37 + 'px',\n      // left: posEl.left + 'px',\n    }\n  }\n})\n\nconst toggleOpen = () => {\n  if (props.multiple && isShow.value) return\n  isShow.value = !isShow.value\n}\n\nconst selectItem = (value) => {\n  if (props.multiple) {\n    setMultipleList(value)\n  } else {\n    searchText.value = null\n    selectedItem.value = value[props.resultKey]\n    emit('select', selectedItem.value, props.target)\n    isShow.value = false\n  }\n}\n\nconst showMenu = (value = true) => {\n  if (\n    elRef.value?.contains(event.target) ||\n    floating.value?.contains(event.target)\n  )\n    return\n  if (isShow.value) value = false\n  isShow.value = value\n}\n\nconst setMultipleList = (item) => {\n  if (selectedList.value.includes(item[props.resultKey])) {\n    const same = selectedList.value.findIndex(\n      (c) => item[props.resultKey] === c,\n    )\n    selectedList.value.splice(same, 1)\n  } else {\n    selectedList.value.push(item[props.resultKey])\n  }\n  emit('select', selectedList.value, props.target)\n}\n\nconst selectAll = () => {\n  selectedList.value = [...searchedOptions.value].map(\n    (se) => se[props.resultKey],\n  )\n  emit('select', selectedList.value, props.target)\n}\n</script>\n\n<template>\n  <div\n    class=\"be-select-box\"\n    :class=\"[boxType, { multiple, fluid, disabled, round }, { show: isShow }]\"\n    @click=\"toggleOpen\"\n    ref=\"elRef\"\n  >\n    <div class=\"selected-item\" ref=\"reference\">\n      <template v-if=\"!isSearch\">\n        <div class=\"default-text\" :class=\"{ has: selectedItem }\">\n          {{ selectedText || placeholder }}\n        </div>\n      </template>\n      <template v-else>\n        <div\n          class=\"be-input icon right\"\n          :class=\"{ fluid, disabled, round, has: selectedItem }\"\n        >\n          <input\n            type=\"text\"\n            :placeholder=\"selectedText || placeholder\"\n            v-model=\"searchText\"\n            :readonly=\"!isSearch || !isShow\"\n          />\n        </div>\n      </template>\n      <i\n        v-if=\"isShow && multiple\"\n        class=\"icon xi-close\"\n        :style=\"{ pointerEvents: 'auto' }\"\n        @click.stop=\"isShow = false\"\n      ></i>\n      <i v-else class=\"icon xi-angle-down\"></i>\n    </div>\n    <Teleport to=\"body\">\n      <div\n        v-if=\"isShow\"\n        class=\"be-popper-container\"\n        ref=\"floating\"\n        :style=\"customFloatingStyle\"\n      >\n        <Transition name=\"extend-fade\">\n          <div\n            v-if=\"isShow\"\n            class=\"select-menu be-popper\"\n            :style=\"[optionsHeight, setMenuStyle]\"\n          >\n            <div class=\"be-list selection\" :class=\"selectedType\" ref=\"menu\">\n              <div\n                v-if=\"isSearch && searchedOptions.length === 0\"\n                class=\"no-searched\"\n              >\n                검색 결과가 없습니다.\n              </div>\n              <template v-else>\n                <div\n                  v-if=\"isAll && multiple\"\n                  class=\"item option-item\"\n                  @click=\"selectAll\"\n                >\n                  전체\n                </div>\n                <div\n                  class=\"item option-item\"\n                  v-for=\"(opt, idx) in searchedOptions\"\n                  :key=\"`option-${idx}`\"\n                  :class=\"[\n                    { selected: opt[resultKey] === selectedItem },\n                    { include: selectedList.includes(opt[resultKey]) },\n                  ]\"\n                  @click=\"selectItem(opt, idx)\"\n                >\n                  <template v-if=\"useIcon\">\n                    <i class=\"list-icon icon\" :class=\"opt.icon\"></i>\n                  </template>\n                  <div class=\"item-title\">\n                    {{ opt[props.optionKey] }}\n                  </div>\n                </div>\n              </template>\n            </div>\n          </div>\n        </Transition>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<style lang=\"scss\">\n.no-searched {\n  padding: 0.5rem;\n}\n.be-select-box {\n  .be-list {\n    .item {\n      padding: 1rem;\n    }\n  }\n  .be-input {\n    &.has input::placeholder {\n      opacity: 1;\n      color: var(--txt);\n    }\n  }\n}\n// .select-menu {\n//   position: absolute;\n//   inset: 0 auto auto 0;\n//   display: block;\n//   transform: translateY(0);\n//   overflow-y: auto;\n//   opacity: 1;\n// }\n.extend-fade-enter-active,\n.extend-fade-leave-active {\n  transition:\n    opacity 0.25s,\n    transform 0.25s;\n}\n.extend-fade-leave-active {\n  transition: transform 0.25s;\n}\n.extend-fade-enter-from,\n.extend-fade-leave-to {\n  opacity: 0;\n  transform: translateY(-10px);\n}\n</style>\n", "<script setup>\ndefineProps({\n  type: {\n    type: String,\n    default: 'slide',\n    varidator: (value) => {\n      return ['slide', 'button', 'button-slide'].includes(value)\n    },\n  },\n  inside: {\n    type: Boolean,\n    default: false,\n  },\n  round: {\n    type: Boolean,\n  },\n  onText: {\n    type: String,\n    default: 'ON',\n  },\n  offText: {\n    type: String,\n    default: 'OFF',\n  },\n  color: {\n    type: String,\n  },\n})\nconst switchValue = defineModel()\nconst emit = defineEmits(['change'])\n\nconst onClick = () => {\n  switchValue.value = !switchValue.value\n  emit('change', switchValue.value)\n}\n</script>\n<template>\n  <div\n    class=\"be-switch\"\n    :class=\"[type, { inside }, { round: round }, color]\"\n    @click=\"onClick\"\n  >\n    <input type=\"checkbox\" v-model=\"switchValue\" />\n    <template v-if=\"type === 'slide'\">\n      <div class=\"switch\"></div>\n    </template>\n    <template v-else>\n      <span class=\"on\" :class=\"{ active: switchValue }\">{{ onText }}</span>\n      <span class=\"off\" :class=\"{ active: !switchValue }\">{{ offText }}</span>\n    </template>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed } from 'vue'\n\nconst props = defineProps({\n  columns: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  values: {\n    type: Array,\n    default: () => {\n      return []\n    },\n  },\n  headerAlign: {\n    type: String,\n    default: 'center',\n  },\n  useFoot: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  gridType: {\n    type: String,\n    default: null,\n  },\n  divideNum: {\n    type: [String || Number],\n    default: 3,\n  },\n  selection: {\n    type: Boolean,\n    default: false,\n  },\n  striped: {\n    type: String,\n    default: null,\n  },\n})\nconst emit = defineEmits(['select'])\nconst selectedRow = ref('')\nconst gridClass = computed(() => {\n  if (props.gridType === 'divide') {\n    return `divide-${props.divideNum}`\n  } else {\n    return props.gridType\n  }\n})\n\nconst setSelect = (row) => {\n  if (!props.selection) return\n  selectedRow.value = selectedRow.value === row ? null : row\n  emit('select', props.values[selectedRow.value] || null)\n}\n</script>\n\n<template>\n  <table\n    class=\"be-table\"\n    :class=\"[{ border, selection, striped }, gridClass, striped]\"\n  >\n    <thead>\n      <tr :class=\"`align-${headerAlign}`\">\n        <th\n          v-for=\"col in columns\"\n          :key=\"col.key\"\n          :class=\"`align-${headerAlign}`\"\n        >\n          {{ col.name }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr\n        v-for=\"(row, i) in values\"\n        :key=\"`row-${i}`\"\n        :class=\"{ select: selectedRow === i }\"\n        @click=\"setSelect(i)\"\n      >\n        <td\n          v-for=\"col in columns\"\n          :key=\"`cell-${i}-${col.key}`\"\n          :class=\"[`align-${col.align || 'center'}`, `col-${col.col}`]\"\n        >\n          <div class=\"cell\">\n            {{ row[col.key] }}\n          </div>\n        </td>\n      </tr>\n    </tbody>\n    <!-- <tfoot v-if=\"useFoot\">\n      <tr>\n        <slot name=\"footer\">\n          <td :colspan=\"columns.length\">Footer</td>\n        </slot>\n      </tr>\n    </tfoot> -->\n  </table>\n</template>\n", "<script setup>\nimport { ref } from 'vue'\nconst props = defineProps({\n  node: {\n    type: Object,\n    default: () => {\n      return {}\n    },\n  },\n  level: {\n    type: Number,\n    default: 0,\n  },\n  useCheck: {\n    type: Boolean,\n    default: false,\n  },\n  useMark: {\n    type: Boolean,\n    default: true,\n  },\n  check: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst showNode = ref(false)\nconst checked = ref(props.check)\nconst toggleNode = (e) => {\n  if (e.target.tagName === 'LABEL') return\n  showNode.value = !showNode.value\n}\n</script>\n<template>\n  <div\n    class=\"be-tree\"\n    :class=\"{ show: showNode }\"\n    :style=\"{ '--level': level }\"\n  >\n    <div class=\"node custom-node\" @click=\"toggleNode\">\n      <div class=\"node-title\">\n        <i\n          v-if=\"useMark\"\n          class=\"icon expend-icon\"\n          :class=\"{ 'xi-caret-down-min': node.children?.length > 0 }\"\n        ></i>\n        <div class=\"node-label\">\n          <template v-if=\"useCheck\">\n            <be-check-box v-model=\"checked\" @update:modelValue=\"updateCheck\" />\n          </template>\n          <div class=\"title\">\n            {{ node.label }}\n          </div>\n          <div v-if=\"node.sub\" class=\"sub-title\">{{ node.sub }}</div>\n        </div>\n      </div>\n    </div>\n    <div v-if=\"showNode && node.children?.length > 0\" class=\"node-children\">\n      <be-tree-node\n        v-for=\"(child, i) in node.children\"\n        :key=\"`level-${level}-${i + 1}`\"\n        :node=\"child\"\n        :level=\"level + 1\"\n        :use-check=\"useCheck\"\n        :use-mark=\"useMark\"\n        :check=\"check\"\n      />\n    </div>\n  </div>\n</template>\n", "const lastDayList = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nexport const week_kr = ['일', '월', '화', '수', '목', '금', '토']\nexport const week_kr_l = [\n  '일요일',\n  '월요일',\n  '화요일',\n  '수요일',\n  '목요일',\n  '금요일',\n  '토요일',\n]\nexport const week_en_s = ['S', 'M', 'T', 'W', 'T', 'F', 'S']\nexport const week_en_m = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']\n// const week_en_l = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\nexport const week_en_l = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n]\nexport const MONTH_TEXT_LIST = [\n  'January',\n  'February',\n  'March',\n  'April',\n  'May',\n  'June',\n  'July',\n  'August',\n  'September',\n  'October',\n  'November',\n  'December',\n]\nexport const MONTH_TEXT_LIST_SHORT = [\n  'Jan.',\n  'Feb.',\n  'Mar.',\n  'Apr.',\n  'May',\n  'Jun.',\n  'Jul.',\n  'Aug.',\n  'Sep.',\n  'Oct.',\n  'Nov.',\n  'Dec.',\n]\n\nexport const getDateInfo = (date = new Date()) => {\n  const newDate = typeof date === 'string' ? new Date(date) : date\n  const y = newDate.getFullYear()\n  const m = newDate.getMonth() + 1\n  const d = newDate.getDate()\n  return { year: y, month: m, date: d }\n}\nconst getStartDay = (year, month) => {\n  let startIndex = 0\n\n  let basicDay = 365 * (year - 1) // 현재 월 기준 전년까지 기본 일 수\n  // 윤년 계산\n  let leafDay =\n    Math.floor((year - 1) / 4) -\n    Math.floor((year - 1) / 100) +\n    Math.floor((year - 1) / 400)\n  // 현재 해 오늘까지의 일 수\n  let currentYearDay = 1\n\n  if (month > 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n    lastDayList[1] = 29\n  } else {\n    lastDayList[1] = 28\n  }\n\n  for (let i = 0; i < month - 1; i++) {\n    currentYearDay += lastDayList[i]\n  }\n  startIndex = (basicDay + leafDay + currentYearDay) % 7\n  return startIndex\n}\n\nexport const setCalendar = ({ year, month, date }) => {\n  const now = getDateInfo()\n  let startDay = getStartDay(year, month)\n\n  let dayList = []\n\n  let currLast = lastDayList[month - 1]\n  let prevLast = month === 1 ? 31 : lastDayList[month - 2]\n\n  let currDay = 1\n  let nextDay = 1\n\n  for (let i = 0; i < 6; i++) {\n    for (let j = 0; j < 7; j++) {\n      let cell = {\n        position: {\n          x: 0,\n          y: 0,\n        },\n        disabled: false,\n        type: [],\n        name: '',\n      }\n      cell.position.x = j\n      cell.position.y = i\n      if (i === 0 && j < startDay) {\n        cell.type.push('prev')\n        cell.name = prevLast + (j - startDay) + 1\n      } else if (currDay <= currLast) {\n        if (j === 0) {\n          cell.type.push('sun')\n        }\n        if (j === 6) {\n          cell.type.push('sat')\n        }\n        if (now.year === year && now.month === month && currDay === now.date) {\n          cell.type.push('today')\n        }\n        cell.name = currDay\n        currDay++\n      } else {\n        cell.type.push('next')\n        cell.name = nextDay\n        nextDay++\n      }\n      dayList.push(cell)\n    }\n  }\n  if (nextDay > 7) {\n    dayList = dayList.slice(0, -7)\n  }\n  return dayList\n}\n\n//\n// document.getElementById('calDate').addEventListener('click', () => {\n//     const result = setCalendar(2022, 11);\n//     console.log(result);\n// })\n", "<script setup>\nimport {\n  setCalendar,\n  getDateInfo,\n  week_en_m,\n  MONTH_TEXT_LIST,\n} from './calendar'\nimport { ref, watch, computed } from 'vue'\n\nconst week = week_en_m\n\nconst props = defineProps({\n  selectedDate: {\n    type: [String, Date],\n    default: new Date(),\n  },\n  cellSize: {\n    type: String,\n    default: '37px',\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  symmetry: {\n    type: Boolean,\n    default: false,\n  },\n  today: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emits = defineEmits(['select'])\n\nconst currentDate = ref(null)\nconst selectDate = ref(null)\nconst dayList = ref([])\n\nconst cellRows = computed(() => {\n  return dayList.value.length / 7\n})\nwatch(\n  () => props.selectedDate,\n  (value) => {\n    const newValue = typeof value === 'string' ? new Date(value) : value\n    currentDate.value = getDateInfo(newValue)\n    selectDate.value = getDateInfo(newValue)\n    dayList.value = setCalendar(currentDate.value)\n  },\n  { immediate: true },\n)\n\nconst setDayList = () => {\n  if (currentDate.value) {\n    dayList.value = setCalendar(currentDate.value)\n  }\n}\n\nconst prevMonth = () => {\n  currentDate.value.month -= 1\n  if (currentDate.value.month <= 0) {\n    currentDate.value.year -= 1\n    currentDate.value.month = 12\n  }\n  setDayList()\n}\nconst nextMonth = () => {\n  currentDate.value.month += 1\n  if (currentDate.value.month > 12) {\n    currentDate.value.year += 1\n    currentDate.value.month = 1\n  }\n  setDayList()\n}\n\nconst setSelectDate = (date) => {\n  const { year, month } = currentDate.value\n  currentDate.value.date = date\n  selectDate.value = {\n    year,\n    month,\n    date,\n  }\n\n  emits('select', new Date(year, month - 1, date))\n}\nconst checkSelectDate = (date) =>\n  currentDate.value.year === selectDate.value.year &&\n  currentDate.value.month === selectDate.value.month &&\n  currentDate.value.date === date\n\nconst setToday = () => {\n  currentDate.value = getDateInfo()\n  selectDate.value = getDateInfo()\n\n  emits('select', new Date())\n  setDayList()\n}\n</script>\n\n<template>\n  <div\n    class=\"be-calendar\"\n    :class=\"{ border }\"\n    :style=\"{ '--cell-size': cellSize }\"\n  >\n    <div class=\"calendar-header\" :class=\"{ symmetry }\">\n      <slot name=\"current-date\">\n        <div class=\"current-date\">\n          <span class=\"month\">{{\n            MONTH_TEXT_LIST[currentDate.month - 1]\n          }}</span>\n          <span class=\"year\">{{ currentDate.year }}</span>\n        </div>\n      </slot>\n      <slot name=\"controller\">\n        <div class=\"prev-month be-button text icon small\" @click=\"prevMonth\">\n          <i class=\"icon xi-angle-left\" />\n        </div>\n        <div class=\"next-month be-button text icon small\" @click=\"nextMonth\">\n          <i class=\"icon xi-angle-right\" />\n        </div>\n      </slot>\n      <div\n        v-if=\"today\"\n        class=\"be-button small compact round outline deepblue\"\n        @click=\"setToday\"\n      >\n        Today\n      </div>\n    </div>\n    <div class=\"week-wrapper\">\n      <div\n        class=\"cell week-cell\"\n        v-for=\"day in week\"\n        :key=\"day\"\n        :data-name=\"day\"\n      ></div>\n    </div>\n    <div class=\"cell-wrapper\" :style=\"{ '--cell-rows': cellRows }\">\n      <div\n        class=\"cell\"\n        v-for=\"day in dayList\"\n        :key=\"day\"\n        :data-name=\"day.name\"\n        :class=\"[...day.type, { selected: checkSelectDate(day.name) }]\"\n        :style=\"{ '--x': day.position.x, '--y': day.position.y }\"\n        @click=\"setSelectDate(day.name)\"\n      ></div>\n    </div>\n    <slot name=\"footer\">\n      <div class=\"calendar-footer\"></div>\n    </slot>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped></style>\n", "<script setup>\nimport { ref, computed, onMounted, onUnmounted } from 'vue'\nimport { useFloating, autoUpdate, offset, flip, shift } from '@floating-ui/vue'\n\nconst props = defineProps({\n  selectedDate: {\n    type: [String, Date],\n    default: new Date(),\n  },\n  cellSize: {\n    type: String,\n    default: '37px',\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  symmetry: {\n    type: Boolean,\n    default: false,\n  },\n  today: {\n    type: Boolean,\n    default: false,\n  },\n})\n\nconst emits = defineEmits(['select'])\n\nconst el = ref(null)\nconst isShow = ref(false)\nconst date = ref(props.selectedDate)\nconst reference = ref(null)\nconst floating = ref(null)\n\nconst { floatingStyles, isPositioned } = useFloating(reference, floating, {\n  placement: 'bottom-start',\n  middleware: [offset(10), flip(), shift()],\n  whileElementsMounted: autoUpdate,\n})\n\nconst setSelectedData = (payload) => {\n  date.value = payload\n  emits('select', date.value)\n}\n\nconst formattedDate = computed(() => {\n  let dateValue = date.value\n  if (typeof dateValue === 'string') dateValue = new Date(dateValue)\n  const year = dateValue.getFullYear()\n  const month = dateValue.getMonth() + 1\n  const day = dateValue.getDate()\n\n  return `${year}.${String(month).padStart(2, '0')}.${String(day).padStart(2, '0')}`\n})\n\nconst menuStyle = ref(null)\nconst MAX_MENU_HEIGHT = 350\n\nconst toggleOpen = () => {\n  isShow.value = !isShow.value\n}\n\nconst showMenu = (value = true) => {\n  if (el.value.contains(event.target) || floating.value.contains(event.target))\n    return\n  if (isShow.value) value = false\n  isShow.value = value\n}\n\nonMounted(() => {\n  document.addEventListener('click', () => showMenu(false))\n})\nonUnmounted(() => {\n  document.removeEventListener('click', () => showMenu(false))\n})\n</script>\n\n<template>\n  <div class=\"be-date-picker\" ref=\"el\">\n    <div class=\"default-date-text\" ref=\"reference\" @click=\"toggleOpen\">\n      <div class=\"be-button icon small round\">\n        <i class=\"icon xi-calendar\"></i>\n      </div>\n      <input type=\"text\" readonly :value=\"formattedDate\" />\n      <i class=\"icon xi-angle-down\" :class=\"{ 'xi-rotate-180': isShow }\"></i>\n    </div>\n    <Teleport to=\"body\">\n      <div class=\"be-popper-container\" ref=\"floating\" :style=\"[floatingStyles]\">\n        <Transition name=\"expend-fade\">\n          <div\n            v-if=\"isShow\"\n            class=\"calender-wrapper be-popper\"\n            :style=\"menuStyle\"\n          >\n            <BeCalendar\n              :selected-date=\"date\"\n              :cell-size=\"cellSize\"\n              :border=\"border\"\n              :symmetry=\"symmetry\"\n              :today=\"today\"\n              @select=\"setSelectedData\"\n            >\n              <div class=\"calendar-footer\">\n                <template slots=\"footer\">\n                  <div class=\"be-button\">Close</div>\n                </template>\n              </div>\n            </BeCalendar>\n          </div>\n        </Transition>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.be-date-picker {\n  position: relative;\n  .default-date-text {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 6px 10px;\n    border-radius: 0.25rem;\n    // border: 1px solid var(--brd);\n    box-shadow: 0 0 0 1px var(--brd);\n\n    input {\n      outline: 0;\n      font-weight: 600;\n      color: #555;\n    }\n  }\n}\n.calender-wrapper1 {\n  position: absolute;\n  top: 100%;\n  margin-top: 10px;\n  background-color: var(--bgc);\n  z-index: 9999;\n  box-shadow: var(--depth-bs);\n  border-radius: 14px;\n}\n</style>\n", "<script setup>\nimport { ref } from 'vue'\ndefineProps({\n  surface: {\n    type: Boolean,\n    default: false,\n  },\n  border: {\n    type: Boolean,\n    default: false,\n  },\n  float: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'left',\n  },\n  round: {\n    type: String,\n    default: 'l',\n  },\n  attached: {\n    type: Array,\n    default: null,\n  },\n  collapse: {\n    type: Boolean,\n    default: false,\n  },\n})\nconst showDetail = ref(false)\nconst toggleCollapse = () => {\n  showDetail.value = !showDetail.value\n}\n</script>\n\n<template>\n  <div\n    class=\"be-segment\"\n    :class=\"[\n      { surface, border, float, attached: attached, collapse },\n      { detail: showDetail },\n      `align-${align}`,\n      `round-${round}`,\n    ]\"\n  >\n    <div v-if=\"attached && attached.includes('header')\" class=\"header\">\n      <slot name=\"header\"></slot>\n    </div>\n    <div class=\"contents\">\n      <slot></slot>\n    </div>\n    <div v-if=\"attached && attached.includes('footer')\" class=\"footer\">\n      <slot name=\"footer\"></slot>\n    </div>\n    <div v-if=\"collapse\" class=\"toggle-detail\" @click=\"toggleCollapse\"></div>\n  </div>\n</template>\n", "<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst elRef = ref(null)\n\nonMounted(() => {\n  if (!elRef.value.parentNode.style.position) {\n    elRef.value.parentNode.style.position = 'relative'\n  }\n})\ndefineProps({\n  content: {\n    type: [String, Number],\n  },\n  mark: {\n    type: Boolean,\n    default: false,\n  },\n  shadow: {\n    type: Boolean,\n    default: false,\n  },\n  align: {\n    type: String,\n    default: 'center',\n  },\n  color: {\n    type: String,\n    default: null,\n  },\n})\n</script>\n<template>\n  <div\n    class=\"be-badge\"\n    :class=\"[{ shadow, mark }, `align-${align}`, color]\"\n    ref=\"elRef\"\n  >\n    <slot>{{ content }}</slot>\n  </div>\n</template>\n", "<script setup>\ndefineProps({\n  tabList: {\n    type: Array,\n    default: null,\n  },\n  vertical: {\n    type: Boolean,\n    default: false,\n  },\n  tabType: {\n    type: String,\n    default: null,\n  },\n})\n\nconst selectedTab = defineModel()\nconst emits = defineEmits(['remove'])\n\nconst removeTab = (tab) => {\n  emits('remove', tab)\n}\n</script>\n\n<template>\n  <div class=\"be-tabs\" :class=\"[{ vertical }, tabType]\">\n    <div class=\"tab-menu\">\n      <div\n        class=\"tab-item tab\"\n        v-for=\"tab in tabList\"\n        :key=\"tab\"\n        :class=\"{ active: tab.option === selectedTab }\"\n        @click=\"selectedTab = tab.option\"\n      >\n        <template v-if=\"tabType === 'browser'\">\n          <div class=\"tabText ellipsis\">{{ tab.option }}</div>\n          <div class=\"btn-close\" @click=\"() => removeTab(tab)\">\n            <i class=\"icon xi-close\" />\n          </div>\n        </template>\n        <template v-else>\n          {{ tab.option }}\n        </template>\n      </div>\n    </div>\n    <div class=\"tab-contents\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n", "<script setup>\nimport { ref, computed, watch, onMounted } from 'vue'\nconst props = defineProps({\n  id: [String, Number],\n  trackType: {\n    type: String,\n    default: 'normal', // thin, normal, fat\n  },\n  min: {\n    type: Number,\n    default: 0,\n  },\n  max: {\n    type: Number,\n    default: 100,\n  },\n  unitText: [String, Object],\n  showStep: {\n    type: Boolean,\n    default: false,\n  },\n  stepSize: {\n    type: Number,\n    default: 10,\n  },\n  showLabel: {\n    type: Boolean,\n    default: false,\n  },\n  showValue: {\n    type: Boolean,\n    default: false,\n  },\n  showTooltip: {\n    type: Boolean,\n    default: false,\n  },\n  titleText: {\n    type: String,\n    default: null,\n  },\n  disabled: Boolean,\n  color: {\n    type: String,\n    default: '',\n  },\n})\n\nconst emit = defineEmits(['error'])\nconst resultValue = defineModel(0)\nconst result = ref(0)\n\nconst slider = ref(null)\nconst resultRef = ref(null)\n\nconst container = ref(500)\nconst initialX = ref(null)\nconst initialW = ref(null)\nconst catching = ref(false)\n\nconst startValue = ref(0)\n\nconst setResult = computed(() => ({\n  width: `${result.value}px`,\n  left: `${startValue.value}%`,\n}))\nconst setPosition = computed(() => ({ left: `${result.value}px` }))\n\nconst setResultValue = computed(() => {\n  return (\n    Math.ceil((props.max - props.min) * (result.value / container.value)) +\n    props.min\n  )\n})\n\nconst stepLevel = computed(() => (props.max - props.min) / props.stepSize)\nconst unitSize = computed(() => 100 / stepLevel.value)\n\nconst initValue = () => {\n  if (resultValue.value > props.max) {\n    emit('error', {\n      title: 'errorMaxValue',\n      message: `입력값이 ${props.max}보다 클 수 없습니다.`,\n    })\n    result.value = convertPixel(props.max)\n  } else if (resultValue.value < props.min) {\n    emit('error', {\n      title: 'errorMinValue',\n      message: `입력값이 ${props.max}보다 작을 수 없습니다.`,\n    })\n    result.value = convertPixel(props.min)\n  } else {\n    result.value = convertPixel(resultValue.value)\n  }\n}\nconst convertPercent = (value) => {\n  return (value - props.min) / (props.max - props.min)\n}\nconst convertPixel = (value) => {\n  return container.value * convertPercent(value)\n}\n\nconst updatePos = (distance) => {\n  let offset = initialW.value + distance\n  if (offset < 0) {\n    return 0\n  } else if (offset > container.value) {\n    return container.value\n  } else {\n    return offset\n  }\n}\n\nconst setStateOn = ({ target: control, pageX }) => {\n  if (control.classList.contains('control-btn')) {\n    initialX.value = pageX\n    initialW.value = resultRef.value.offsetWidth\n    catching.value = true\n    window.addEventListener('mousemove', changeValue)\n    window.addEventListener('mouseup', setStateOff)\n  } else {\n    result.value = updatePos(pageX - initialX.value)\n  }\n}\n\nconst setStateOff = ({ target: control, pageX }) => {\n  if (control.classList.contains('control-btn')) {\n    result.value = updatePos(pageX - initialX.value)\n  }\n  resultValue.value = setResultValue.value\n  catching.value = false\n  window.removeEventListener('mousemove', changeValue)\n  window.removeEventListener('mouseup', setStateOff)\n}\n\nconst changeValue = ({ pageX }) => {\n  result.value = updatePos(pageX - initialX.value)\n}\n\nconst selectStep = ({ target: step }) => {\n  console.log(step)\n}\nwatch(\n  resultValue,\n  () => {\n    initValue()\n  },\n  { immediate: true },\n)\n\nonMounted(() => {\n  if (slider.value) {\n    const sliderInfo = slider.value.getBoundingClientRect()\n    container.value = sliderInfo.width\n    initialX.value = sliderInfo.left\n\n    initValue()\n    slide_obs.observe(slider.value)\n  }\n})\n\nlet slide_obs = new ResizeObserver((entries) => {\n  for (let entry of entries) {\n    const entInfo = entry.contentRect\n    container.value = entInfo.width\n    initValue()\n  }\n})\n</script>\n\n<template>\n  <div\n    class=\"be-slider\"\n    ref=\"slider\"\n    :class=\"[{ disabled }, trackType, { labeled: showLabel }]\"\n    @mousedown=\"setStateOn\"\n    @mouseup=\"setStateOff\"\n  >\n    <div\n      class=\"result-slider primary\"\n      :class=\"`be-${color}`\"\n      ref=\"resultRef\"\n      :style=\"setResult\"\n    ></div>\n    <template v-if=\"showStep\">\n      <div\n        class=\"break-point\"\n        v-for=\"point in stepLevel - 1\"\n        :key=\"point\"\n        :style=\"{ left: `${point * unitSize}%` }\"\n        @click.stop=\"selectStep\"\n      ></div>\n    </template>\n    <div class=\"control-btn\" :class=\"{ catching }\" :style=\"setPosition\">\n      <div v-if=\"showTooltip\" class=\"tooltip\">\n        {{ setResultValue }}{{ unitText }}\n      </div>\n    </div>\n    <div v-if=\"showValue\" class=\"label-text\">\n      <div class=\"current-label\" :style=\"{ left: `${result}px` }\">\n        {{ setResultValue }}{{ unitText }}\n      </div>\n    </div>\n    <div v-if=\"showLabel\" class=\"label-text\">\n      <div class=\"start-label\">{{ min }}{{ unitText }}</div>\n      <div class=\"end-label\">{{ max }}{{ unitText }}</div>\n    </div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped></style>\n", "import './beui/beui.scss'\nimport * as components from './components'\n\nconst install = (app) => {\n  // 모든 컴포넌트를 순회하면서 등록\n  Object.entries(components).forEach(([name, component]) => {\n    // 컴포넌트 이름 정규화\n    const componentName = name.startsWith('Be') ? name : `Be${name}`\n    app.component(componentName, component)\n  })\n}\n\n// 컴포넌트 개별 export\nexport * from './components'\n\n// 기본 플러그인 export\nexport default {\n  install,\n  // 개별 컴포넌트도 함께 export\n  ...components,\n}\n"],
  "mappings": "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",
  "names": ["emit", "__emit", "onClick", "e", "selectedIndex", "_useModel", "__props", "handleSelect", "idx", "props", "inputValue", "isFocus", "ref", "input", "iconPosition", "computed", "checkFocus", "onBlur", "onMounted", "increase", "decrease", "keyControl", "event", "checkedValue", "uniqueId", "selectedValue", "checkboxList", "val", "c", "selectCheck", "i", "selectedRadio", "selectItem", "statusIcon", "iconName", "pageEl", "current", "last", "pageList", "offLimits", "n", "start", "half", "isPrevPoint", "isNextPoint", "findStart", "isDisabledNext", "isDisabledPrev", "watch", "nextTick", "setCurrent", "num", "setPrev", "setNext", "setPrevBlock", "prevNum", "setNextBlock", "isOpen", "iconClass", "setHeight", "showPanel", "setValue", "rate", "result", "isHalf", "isFloat", "setFloat", "percent", "onHover", "targetPos", "onMove", "onLeave", "setRate", "min", "max", "round", "floor", "createCoords", "v", "oppositeSideMap", "oppositeAlignmentMap", "clamp", "value", "end", "evaluate", "param", "getSide", "placement", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "yAxisSides", "getSideAxis", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "length", "mainAlignmentSide", "getOppositePlacement", "getExpandedPlacements", "oppositePlacement", "getOppositeAlignmentPlacement", "lrPlacement", "rlPlacement", "tbPlacement", "btPlacement", "getSideList", "side", "isStart", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "expandPaddingObject", "padding", "getPaddingObject", "rectToClientRect", "rect", "x", "y", "width", "height", "computeCoordsFromPlacement", "_ref", "reference", "floating", "sideAxis", "alignLength", "isVertical", "commonX", "commonY", "commonAlign", "coords", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "statefulPlacement", "middlewareData", "resetCount", "name", "fn", "nextX", "nextY", "data", "reset", "detectOverflow", "state", "options", "_await$platform$isEle", "elements", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "element", "clippingClientRect", "offsetParent", "offsetScale", "elementClientRect", "flip", "_middlewareData$arrow", "_middlewareData$flip", "initialPlacement", "checkMainAxis", "checkCrossAxis", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "detectOverflowOptions", "initialSideAxis", "isBasePlacement", "fallbackPlacements", "hasFallbackAxisSideDirection", "placements", "overflow", "overflows", "overflowsData", "sides", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "nextPlacement", "d", "resetPlacement", "a", "b", "_overflowsData$filter2", "currentSideAxis", "acc", "originSides", "convertValueToCoords", "mainAxisMulti", "crossAxisMulti", "rawValue", "mainAxis", "crossAxis", "offset", "_middlewareData$offse", "diffCoords", "shift", "limiter", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "limitedCoords", "hasWindow", "getNodeName", "node", "isNode", "getWindow", "_node$ownerDocument", "getDocumentElement", "isElement", "isHTMLElement", "isShadowRoot", "invalidOverflowDisplayValues", "isOverflowElement", "overflowX", "overflowY", "display", "getComputedStyle", "tableElements", "isTableElement", "topLayerSelectors", "isTopLayer", "selector", "transformProperties", "willChangeValues", "containValues", "isContainingBlock", "elementOrCss", "webkit", "isWebKit", "css", "getContainingBlock", "currentNode", "getParentNode", "isLastTraversableNode", "lastTraversableNodeNames", "getNodeScroll", "getNearestOverflowAncestor", "parentNode", "getOverflowAncestors", "traverseIframes", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "frameElement", "getFrameElement", "getCssDimensions", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "unwrapElement", "getScale", "domElement", "$", "noOffsets", "getVisualOffsets", "shouldAddVisualOffsets", "isFixed", "floatingOffsetParent", "getBoundingClientRect", "includeScale", "isFixedStrategy", "clientRect", "scale", "visualOffsets", "offsetWin", "currentWin", "currentIFrame", "iframeScale", "iframeRect", "left", "top", "getWindowScrollBarX", "leftScroll", "getHTMLOffset", "documentElement", "scroll", "ignoreScrollbarX", "htmlRect", "convertOffsetParentRelativeRectToViewportRelativeRect", "topLayer", "offsets", "isOffsetParentAnElement", "offsetRect", "htmlOffset", "getClientRects", "getDocumentRect", "html", "body", "getViewportRect", "visualViewport", "visualViewportBased", "absoluteOrFixed", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "hasFixedPositionAncestor", "stopNode", "getClippingElementAncestors", "cache", "cachedResult", "el", "currentContainingBlockComputedStyle", "elementIsFixed", "computedStyle", "currentNodeIsContaining", "ancestor", "getClippingRect", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "getDimensions", "getRectRelativeToOffsetParent", "setLeftRTLScrollbarOffset", "isStaticPositioned", "getTrueOffsetParent", "polyfill", "rawOffsetParent", "getOffsetParent", "svgOffsetParent", "getElementRects", "getOffsetParentFn", "getDimensionsFn", "floatingDimensions", "isRTL", "rectsAreEqual", "observeMove", "io", "timeoutId", "root", "cleanup", "_io", "refresh", "skip", "threshold", "elementRectForRootMargin", "insetTop", "insetRight", "insetBottom", "insetLeft", "isFirstUpdate", "handleObserve", "entries", "ratio", "autoUpdate", "update", "ancestorScroll", "ancestorResize", "elementResize", "layoutShift", "animationFrame", "referenceEl", "ancestors", "cleanupIo", "reobserveFrame", "resizeObserver", "firstEntry", "_resizeObserver", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "_resizeObserver2", "offset$1", "shift$1", "flip$1", "mergedOptions", "platformWithCache", "computePosition$1", "isComponentPublicInstance", "target", "toValue", "source", "unref", "getDPR", "roundByDPR", "dpr", "useFloating", "whileElementsMountedOption", "openOption", "_toValue", "middlewareOption", "placementOption", "_toValue2", "strategyOption", "_toValue3", "transformOption", "_toValue4", "referenceElement", "floatingElement", "shallowRef", "isPositioned", "floatingStyles", "initialStyles", "xVal", "yVal", "whileElementsMountedCleanup", "open", "position", "attach", "getCurrentScope", "onScopeDispose", "shallowReadonly", "elRef", "menu", "isShow", "selectedItem", "selectedList", "optionList", "reactive", "searchText", "offsetValue", "customFloatingStyle", "floatOffset", "selectedText", "selectIndex", "t", "searchedOptions", "f", "item", "optionsHeight", "initValue", "showMenu", "onUnmounted", "menuPos", "setMenuStyle", "posEl", "toggleOpen", "setMultipleList", "_a", "_b", "same", "selectAll", "se", "switchValue", "selectedRow", "gridClass", "setSelect", "row", "showNode", "checked", "toggleNode", "lastDayList", "week_en_m", "MONTH_TEXT_LIST", "getDateInfo", "date", "newDate", "m", "getStartDay", "year", "month", "startIndex", "basicDay", "leafDay", "currentYearDay", "setCalendar", "now", "startDay", "dayList", "currLast", "prevLast", "currDay", "nextDay", "j", "cell", "week", "emits", "currentDate", "selectDate", "cellRows", "newValue", "setDayList", "prevMonth", "nextMonth", "setSelectDate", "checkSelectDate", "setToday", "setSelectedData", "payload", "formattedDate", "dateValue", "day", "menuStyle", "showDetail", "toggleCollapse", "selectedTab", "removeTab", "tab", "resultValue", "slider", "resultRef", "container", "initialX", "initialW", "catching", "startValue", "setResult", "setPosition", "setResultValue", "stepLevel", "unitSize", "convertPixel", "convertPercent", "updatePos", "distance", "setStateOn", "control", "pageX", "changeValue", "setStateOff", "selectStep", "step", "sliderInfo", "slide_obs", "entry", "entInfo", "install", "app", "components", "component", "componentName", "index"]
}
